% vim: set ft=tex:

\documentclass[a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{hyperref,cleveref}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{ottalt}
\usepackage{subcaption}
\usepackage{cite,url,babelbib}
\usepackage{todonotes}
\usepackage[english]{babel}

\addtolength{\topmargin}{-1.05in}
\addtolength{\textheight}{1.55in}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\crefname{lemma}{Lemma}{Lemmas}
\crefname{remark}{Remark}{Remarks}

\newcommand{\unit}{\textbf{u}}
\newcommand{\Unit}{\textbf{Unit}}
\newcommand{\unitc}{\hat{\textbf{u}}}
\newcommand{\Unitc}{\widehat{\textbf{Unit}}}
\newcommand{\Int}{\textbf{Int}}
\newcommand{\ctxok}{\text{~ok}}
\newcommand{\fresh}{\text{~fresh name}}
\newcommand{\evalsto}{\rightsquigarrow}
\newcommand{\eqrefl}{\text{eq-refl~}}

\begin{document}

\newNTclass{nonterm}
\newnonterm e \varepsilon
\newnonterm{es}{\varepsilon}
\newnonterm{ec}{\hat\varepsilon}
\newnonterm r \rho
\newnonterm{ts}{\tau}
\newnonterm{tc}{\hat\tau}
\newnonterm s s
\newnonterm l l
\newnonterm B B
\newnonterm G \Gamma
\newnonterm{GC}{\hat\Gamma}
\newnonterm{vs} \varpi
\newnonterm{vc}{\hat\varpi}

\newNTclass{gterm}
\newgterm x x
\newgterm v v
\newgterm n n
\newgterm p \pi

\newcommand{\figref}[1]{Figure \ref{fig:#1}}

\inputott{surface.ott}

\title{Compiling refinement types to dependent types}

\maketitle

\section{Introduction}

\section{Overview}

%TODO describe the notion of the oracle (like an SMT solver) and what we expect of the oracle.

\section{Calculi definitions}

\subsection{Surface language}

Our surface language is based on simply typed lambda calculus.
Refinements over the types are, of course, the most important extension.
The other ones are:
\begin{itemize}
  \item dependent arrow types, to allow subsequent refinements refer preceding arguments,
  \item limited form of algebraic data types and dependent pattern matching
    insired by \cite{TAPLVariants,Eisenberg16},
    to illustrate reasoning about those widely used constructs.
\end{itemize}

The syntax of the surface language is presented in \figref{surface_syntax}.
The typing rules for the surface language are laid out in \figref{surface_typing}.
For the type well-formedness and term typing rules
we also assume each of them has a premise $\nonterm G \ctxok$
stating that the context is well-formed.
The (small-step) operational semantics for the surface language are presented in \figref{surface_opsem}.
That is largely the usual call-by-value evaluation model
with some extra rules for the ADTs and pattern matching.

\begin{figure}[ht]
  \footnotesize
  \begin{subfigure}{.6\textwidth}
    \nonterms{es,l,vs}
    \caption{Term level}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
    \nonterms{G,r,B,ts}
    \caption{Type level}
  \end{subfigure}
  \caption{Surface language syntax}
  \label{fig:surface_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[TCTX]{$[[ G ok ]]$}{context well-formedness}{Empty,Bind}
  \drules[TWF]{$[[ G |- ts ]]$}{type well-formedness}{TrueRef,Base,Conj,Arr,ADT}
  \drules[T]{$[[ G |- es : ts ]]$}{term typing}{Unit,Var,Abs,App,Case,Con,Sub}
  \drules[ST]{$[[ G |- ts1 <: ts2 ]]$}{subtyping}{Base,Arr}
  \caption{Surface language typing}
  \label{fig:surface_typing}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[E]{$[[ es1 ~~> es2 ]]$}{term evaluation}{AppL,AppR,AppAbs,ADT,CaseScrut,CaseMatch}
  \caption{Surface language small-step operational semantics}
  \label{fig:surface_opsem}
\end{figure}

We introduce a shorthand notation $\top$ denoting some tautology
which we use for trivial refinements that do not carry any extra information.
In particular, one good way to define $\top$ is
to state the equality of the sole inhabitant of $\Unit$ to itself:
$\top \triangleq \unit = \unit$.

\begin{remark}\label{remark:surface_base_types}
  The surface language might also have other base types (for example, $\Int$),
  elements of syntax (like numbers and operations on them)
  as well as typing rules relating those,
  but we omit them for the sake of brevity.
\end{remark}

We also have the following concessions:
\begin{itemize}
  \item The syntax only allows refinements on base types.
    Note that this does not restrict the expressive power of the language.
    For instance, a refinement on a function that we might otherwise wish to write as
    \[
      (x : \Int) \rightarrow \{ v : \Int \rightarrow \Int | v x = 0 \} \rightarrow \Int
    \]
    might instead be expressed via a dummy parameter:
    \[
      (x : \Int) \rightarrow (f : \Int \rightarrow \Int) \rightarrow \{ \_ : \Unit | f x = 0 \} \rightarrow \Int.
    \]
  \item Our algebraic data types only allow a single ``field'' in each constructor.
    One way to alleviate this is to introduce tuples,
    but doing so would complicate the exposition
    without any benefit for illustrating the main idea of this work.
\end{itemize}

The translation function $[|\ |]$ maps the typing context $\nonterm G$ to some logic
that the oracle can handle.
It might be defined as follows:
\begin{equation}
\begin{aligned}
  & [|\ \emptyset\ |]                    && \triangleq && \top																			           \\
  & [|\ [[ G , x : { v : B | r } ]] \ |] && \triangleq && [|\ [[ G ]] \ |] \land [|\ [[ [ v |-> x ] r ]] \ |]  \\
  & [|\ [[ r1 /\ r2 ]] \ |]              && \triangleq && [|\ [[ r1 ]] \ |] \land [|\ [[ r2 ]] \ |]            \\
  & [|\ [[ es_1 = es_2 ]] \ |]           && \triangleq && \text{oracle}([[ es_1 = es_2 ]])                     \\
\end{aligned}
\end{equation}

The last equation represents the assumption
that the oracle knows how to translate the atomic refinements.

%TODO define substitutions on the \nonterm r

In the subsequent text we also assume the oracle can decide the resulting proposition
(otherwise it might be left as a separate lemma to be filled out by the user in the core language, or rejected altogether).

\subsubsection{Properties}

\begin{lemma}
  If $[[ G |- es : ts ]]$, then $[[ G ok ]]$.
\end{lemma}
\begin{proof}
  \todo[inline]{Do the proof and remove the assumption $[[ G ok ]]$ from all the rules unless needed.}
\end{proof}

\begin{lemma}
  If $[[ G |- es : ts ]]$, then $[[ G |- ts ]]$.
\end{lemma}
\begin{proof}
  \todo[inline]{Do the proof.}
\end{proof}

\subsection{Core language}

We take $\lambda C$ \cite{TTFPLambdaC}
extended with a unit type
and a restricted form of ADTs as our core dependently typed language.
We conjecture that these extensions
do not break the usual metatheoretical properties of the system,
and we explicitly prove progress and preservation theorems as a sanity check.

The syntax of the core language is presented in \figref{core_syntax},
the core $\lambda C$ typing rules are defined in \figref{core_typing}
and the rules for our extensions are defined in \figref{core_typing_exts}.
Note that the \textsc{CT-ADTCase} rule uses $\equiv$ denoting the equality
which is a derived form defined later.

Even though we believe that our core language still enjoys the strong normalization property,
we still explicitly define the evaluation rules (\figref{core_opsem}).
Firstly, this allows fixing a specific evaluation strategy mirroring the one for the surface language,
simplifying the subsequent proofs of some key theorems.
Secondly, the rule for \textsc{CE-CaseMatch},
as well as our flavour of pattern matching in general,
deserves some special attention.
\todo[inline]{Pay said attention.}

\begin{figure}[ht]
  \footnotesize
  \nonterms{ec,s,vc}
  \caption{Core language syntax}
  \label{fig:core_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[CT]{$[[ GC |- ec1 : ec2 ]]$}{core typing}{Sort,Var,Weaken,Form,App,Abs,Conv}
  \caption{$\lambda C$ typing rules}
  \label{fig:core_typing}
\end{figure}
\begin{figure}[ht]
  \footnotesize
  \drules[CT]{$[[ GC |- ec1 : ec2 ]]$}{core typing, extensions}{UnitType,UnitTerm,ADTForm,ADTCon,ADTCase}
  \caption{Typing rules for our extensions to $\lambda C$}
  \label{fig:core_typing_exts}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[CE]{$[[ ec1 ~~> ec2 ]]$}{term evaluation}{AppL,AppR,AppAbs,ADT,CaseScrut,CaseMatch}
  \caption{Core language small-step operational semantics}
  \label{fig:core_opsem}
\end{figure}

Although the syntax doesn't mention $\nonterm{tc}$, we will use it as a metavariable
where a type (an inhabitant of $\star$) is expected.

In addition to that, we will somewhat frivolously use $\hat B$
to denote the core language analogue of a surface language base type $B$,
which exists for $\Unit$ ($\hat B$ then being $\Unitc$)
and which we assume to exist for any other surface language base type
mentioned in \cref{remark:surface_base_types}.
We also assume that $\hat B$ has type $\star$ without any extra premises.

\newcommand{\dast}{\ **\ }

We also establish some derived forms in the core language to simplify the subsequent exposition,
and state some straightforward facts that will be useful later:
\begin{itemize}
  \item Simplified variable typing rule which we call \textsc{CT-VarW}:
    \[ \ottdruleCTXXVarW{} \]
    This rule unfolds into a single \textsc{CT-Var} defining $x$,
    followed by a sequence of \textsc{CT-Weaken}
    to ``move'' the $x$ into the right position in the final $[[ GC ]]$.
  \item Non-dependent function type:
    \[
      \nonterm{tc}_1 \rightarrow \nonterm{tc}_2 \triangleq \Pi \_ : \nonterm{tc}_1. \nonterm{tc}_2.
    \]
  \item Dependent pair type, or $\Sigma$-type, with the first component being a value $x$ of type $\tau$ and the second component being of type $P x$:
    \[
      (x : \nonterm{tc} \dast P x) \triangleq \Pi \alpha : \star. (\Pi x : \nonterm{tc}. P x \rightarrow \alpha) \rightarrow \alpha,
    \]
    with the corresponding constructor (we overload the syntax here to resemble Idris):
    \[
      (x \dast p) \triangleq \lambda \alpha : \star. \lambda f : (\Pi x' : \nonterm{tc}. P x' \rightarrow \alpha). f x p
    \]
    and projections
    \[
      \text{fst} \triangleq \lambda \sigma : (x : \nonterm{tc} \dast P x). \sigma \nonterm{tc} (\lambda x' : \nonterm{tc}. \lambda \_ : P x'. x'),
    \]
    \[
      \text{snd} \triangleq \lambda \sigma : (x : \nonterm{tc} \dast P x). \sigma \nonterm{tc} (\lambda x' : \nonterm{tc}. \lambda p : P x'. p).
    \]
    It is easy to see from the formation rule that
    \begin{lemma}\label{lma:dep_pair_typing}
      If $\nonterm{tc}$ is typeable in $\nonterm{GC}$
      and $P x$ is typeable in $\nonterm{GC} , x : \nonterm{tc}$,
      then $(x : \nonterm{tc} \dast P x)$ is also typeable in $\nonterm{GC}$ and,
      in particular, it has type $\star$.
    \end{lemma}
  \item Non-dependent pair type:
    \[
      (\nonterm{tc}_1, \nonterm{tc}_2) \triangleq \{ x : \nonterm{tc}_1\ **\ (\lambda \_ : \nonterm{tc}_1. \nonterm{tc}_2) x \}.
    \]
    As a direct consequence of the previous lemma we obtain
    \begin{lemma}\label{lma:non_dep_pair_typing}
      If $\nonterm{tc}_1, \nonterm{tc}_2$ are typeable in $\nonterm{GC}$,
      then $(\nonterm{tc}_1, \nonterm{tc}_2)$ is typeable in $\nonterm{GC}$ and has type $\star$.
    \end{lemma}
  \item Equality of expressions $\nonterm{ec}_1, \nonterm{ec}_2$ of type $\nonterm{tc}$:
    \[
      \nonterm{ec}_1 \equiv \nonterm{ec}_2
        \triangleq
        \Pi P : \nonterm{tc} \rightarrow \star. (P \nonterm{ec}_1 \rightarrow P \nonterm{ec}_2, P \nonterm{ec}_2 \rightarrow P \nonterm{ec}_1).
    \]
    The reader might recognize this as the Leibniz equality \cite{FindSomethingForThis}.

    The corresponding introduction rule $\eqrefl x$ of type $x \equiv x$
    stating that $x$ of type $\nonterm{tc}$ is equal to itself
    is then
    \[
      \eqrefl x \triangleq \lambda P : \nonterm{tc} \rightarrow \star. (\lambda p : P x. p, \lambda p : P x. p).
    \]

    Again, it can be seen that
    \begin{lemma}\label{lma:equality_typing}
      If $\nonterm{ec}_1, \nonterm{ec}_2$ are well-typed in a context $\nonterm{GC}$,
      then $\nonterm{GC} \vdash \nonterm{ec}_1 \equiv \nonterm{ec}_2 : \star$.
    \end{lemma}
\end{itemize}

\section{Translation}

\newcommand{\tranty}{\mu_\tau}
\newcommand{\tranterm}{\mu_\varepsilon}

\newcommand{\Tranctx}{\mu_{\vdash\Gamma}}
\newcommand{\Tranty}{\mu_{\vdash\tau}}
\newcommand{\Tranterm}{\mu_{\vdash\varepsilon}}

The surface language ultimately gets translated into the core language.
What really matters for practical purposes is the translation of the terms since
terms, not types or contexts, will eventually be compiled down to some executable code.
On the other hand, it seems desirable to ensure that the terms
that are well-typed in the surface language
are accepted by the core type checker after the translation,
since this provides some level of guarantee that the translation ``makes sense''.

In particular, note that the oracle plays a crucial role in typechecking of the surface language,
so it is natural to expect that its output will also be used during any such translation,
for instance, to produce core language proofs that VCs hold.
The only trace of the oracle's work is in the typing derivation
(namely, in the subtyping relation check and the \textsc{T-Sub} typing rule),
so we choose to do the translation not on \emph{terms},
but rather on \emph{well-typedness derivations} for the terms.
This way the oracle has a chance to enrich the original surface language term
with proofs and witnesses of whatever it decided.

Thus the ultimate goal of this section is to define a function $\Tranterm$
taking a typing derivation in the surface language
and producing a typing derivation in the core language.
As part of its duty
this function also needs to translate the types and contexts
encountered in the source derivation,
so we also define two helper functions.
$\Tranty$ takes a surface derivation of a \emph{type} well-formedness
and produces the corresponding core derivation.
$\Tranctx$ takes a surface derivation of a \emph{context} well-formedness
and produces a core language context.

We also define two helper functions, $\tranty$ and $\tranterm$,
invoking $\Tranty$ and $\Tranterm$ and extracting just the type and term component respectively.

All in all, our goal is to define $\Tranctx$, $\Tranty$ and $\Tranterm$
with ``metatypes''
\begin{align*}
  \Tranctx  & : [[ G ok ]]         \longmapsto [[ GC ]],             \\
  \Tranty   & : [[ G |- ts ]]      \longmapsto [[ GC |- tc : sst ]], \\
  \Tranterm & : [[ G |- es : ts ]] \longmapsto [[ GC |- ec : tc ]].
\end{align*}
Our helper functions $\tranty$ and $\tranterm$ are then defined to return the $\nonterm{tc}$ and $\nonterm{ec}$
from the respective right-hand sides.

The apparent asymmetry of $\Tranctx$, which does not produce a derivation as others do,
is due to our core language not having a separate notion of a context well-formedness.

\paragraph{Contexts.}
As a warm-up,
we start with defining $\Tranctx$,
which is the simplest of the three.
It merely maps the types of the bindings in a (well-formed) context
from the surface language into the core language.

Since $\Tranctx$ is defined on the derivations of $[[ G ok ]]$,
consider the last rule used in a derivation:
\begin{itemize}
  \item \textsc{TCTX-Empty}.
    \begin{align*}
      & \inferrule{~}
                  {\emptyset \ctxok}
          \longmapsto
        \emptyset.
    \end{align*}
    The base case is trivial: the empty context is mapped to the empty context.
  \item \textsc{TCTX-Bind}.
    \begin{align*}
      & \inferrule{\nonterm G \ctxok \\ \nonterm G \vdash \nonterm{ts}}
                  {\nonterm G , \gterm x : \nonterm{ts} \ctxok}
          \longmapsto
        \Tranctx(\nonterm G \ctxok), x : \tranty(\nonterm G \vdash \nonterm{ts}).
    \end{align*}

    We recurse on the prefix $[[ G ]]$,
    which is admissible due to the $[[ G ok ]]$ premise,
    and we use $\tranty$ to get the translated type of $\gterm x$,
    which is also admissible due to the other premise.
\end{itemize}

\paragraph{Types.}
Next, we define $\Tranty$. In short:
\begin{itemize}
  \item (dependent) arrow types are translated to the corresponding $\Pi$-types,
  \item refined types are translated to the corresponding $\Sigma$-types,
  \item atomic refinements, being propositions about surface language terms equality,
    are translated to propositions stating the equality of translated core language terms,
  \item conjunctions of several (atomic) refinements are represented as tuples of the corresponding atomic translations.
\end{itemize}

More formally, consider the last rule used in the derivation of $[[ G |- ts ]]$:
\begin{itemize}
  \item \textsc{TWF-TrueRef}.
    \begin{align*}
      & \inferrule{\nonterm G \ctxok}
                  {\nonterm G \vdash \{ v : B | \top \}}
          \longmapsto
        \inferrule{\cdots}
                  {\nonterm{GC} \vdash (\hat B, \unitc \equiv \unitc) : \star}, \\
      \text{where}~&\nonterm{GC} = \Tranctx(\nonterm G \ctxok).
    \end{align*}

    By \cref{lma:non_dep_pair_typing}
    $(\hat B, \unitc \equiv \unitc)$ has type $\star$ in $\nonterm{GC}$
    if $\hat B$ and $\unitc \equiv \unitc$ are well-typed in $\nonterm{GC}$,
    which, in turn, is easily checked.
    Thus, there exists a derivation of $\nonterm{GC} \vdash (\hat B, \unitc \equiv \unitc) : \star$,
    and it is effectively constructible, although omitted for brevity.
  \item \textsc{TWF-Base}.
    \begin{align*}
      & \inferrule{\nonterm G \ctxok \\\\
                   \nonterm G ' \vdash \nonterm{es}_1 : \{ v_2 : B' | \nonterm{r}_1 \} \\\\
                   \nonterm G ' \vdash \nonterm{es}_2 : \{ v_2 : B' | \nonterm{r}_2 \} \\\\
                   \gterm x \fresh}
                  {\nonterm G \vdash \{ v : B | \nonterm{es}_1 = \nonterm{es}_2 \}}
          \longmapsto
        \inferrule{\Tranterm(\nonterm G ' \vdash \nonterm{es}_1 : \{ v_2 : B' | \nonterm{r}_1 \}) \\\\
                   \Tranterm(\nonterm G ' \vdash \nonterm{es}_2 : \{ v_2 : B' | \nonterm{r}_2 \}) \\\\
                   \gterm x \fresh \\\\
                   \cdots}
                  {\nonterm{GC} \vdash (v : \hat B \dast \lambda v : \hat B. \nonterm{ec}_1 \equiv \nonterm{ec}_2) : \star}, \\
      \text{where}~&\nonterm{GC} = \Tranctx(\nonterm G \ctxok), \\
                   &\nonterm G ' = \nonterm G , v : \{ v_1 : B | \top \}, \\
                   &\nonterm{ec}_i =
                     \tranterm(\nonterm G ' \vdash \nonterm{es}_i : \{ v_2 : B' | \nonterm{r}_i \}).
    \end{align*}

    To see that this is well-defined, first note that
    that $\hat B$ has type $\star$ by assumption on $\hat B$.
    Then, $\nonterm{ec}_1$ and $\nonterm{ec}_2$ are well-typed in the translated context $\nonterm G'$ according to the premises,
    and this context coincides with the one used to type check $\lambda v : \hat B. \nonterm{ec}_1 \equiv \nonterm{ec}_2$.
    Hence both components of the dependent pair are well-typed, so by \cref{lma:dep_pair_typing} the dependent pair itself has type $\star$.

    \todo[inline]{
      The ${ v : B | \top }$ in the $\nonterm G '$ desugars to a dependent pair, yet we use $\lambda v : \hat B$ — note the naked base type.
      Figure out how to best fix this.
    }

    Just as in the previous case, the extra derivations and premises corresponding to the considerations above
    are omitted and denoted by $\cdots$.
  \item \textsc{TWF-Conj}.
    \begin{align*}
      & \inferrule{\nonterm G \ctxok \\\\
                   \nonterm G \vdash \{ v : B | \nonterm{r}_1 \} \\
                   \nonterm G \vdash \{ v : B | \nonterm{r}_2 \}}
                  {\nonterm G \vdash \{ v : B | \nonterm{r}_1 \land \nonterm{r}_2 \}}
          \longmapsto
        \inferrule{\cdots \\\\
                   \Tranty(\nonterm G \vdash \{ v : B | \nonterm{r}_1 \}) \\
                   \Tranty(\nonterm G \vdash \{ v : B | \nonterm{r}_2 \})}
                  {\nonterm{GC} \vdash (v : \hat B \dast \lambda v : \hat B. (P_1 v, P_2 v)) : \star}, \\
      \text{where}~&\nonterm{GC} = \Tranctx(\nonterm G \ctxok),                                         \\
                   &P_1 \text{~s.t.~} (v : \hat B \dast \lambda v : \hat B. P_1 v) = \tranty(\nonterm G \vdash \{ v : B | \nonterm{r}_1 \}),  \\
                   &P_2 \text{~s.t.~} (v : \hat B \dast \lambda v : \hat B. P_2 v) = \tranty(\nonterm G \vdash \{ v : B | \nonterm{r}_2 \}).
    \end{align*}

    The proof of the right-hand side being well-defined goes similarly to the cases considered previously,
    but with an extra step.
    Namely, note that the last two ``patterns'' on the left-hand side are irrefutable:
    it can be seen by direct inspection and inductive reasoning that $\tranty$ always yields a pair
    for a derivation of the form $\nonterm G \vdash \{ v : B | \nonterm{r} \}$.
    Thus we can take the predicate components $P_1, P_2$ out from the corresponding dependent pairs
    and repack them obtaining $\lambda v : \hat B. (P_1 v, P_2 v)$.
  \item \textsc{TWF-Arr}.
    \begin{align*}
      & \inferrule{\nonterm G \ctxok \\\\
                   \nonterm G \vdash \nonterm{ts}_1 \\
                   \nonterm G , \gterm x : \nonterm{ts}_1 \vdash \nonterm{ts}_2}
                  {\nonterm G \vdash (\gterm x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2}
          \longmapsto
        \inferrule{\Tranty(\nonterm G \vdash \nonterm{ts}_1) \\
                   \Tranty(\nonterm G , \gterm x : \nonterm{ts}_1 \vdash \nonterm{ts}_2)}
                  {\nonterm{GC} \vdash \Pi x : \nonterm{tc}_1. \nonterm{tc}_2 : \star}, \\
      \text{where}~&\nonterm{GC} = \Tranctx(\nonterm G \ctxok),                                         \\
                   &\nonterm{tc}_1 = \tranty(\nonterm G \vdash \nonterm{ts}_1),                         \\
                   &\nonterm{tc}_2 = \tranty(\nonterm G , \gterm x : \nonterm{ts}_1 \vdash \nonterm{ts}_2).
    \end{align*}

    The rule \textsc{CT-Form} is used on the right.
    This is admissible,
    since $\Tranty(\nonterm G \vdash \nonterm{ts}_1)$ produces a derivation of $\nonterm{GC} \vdash \nonterm{tc}_1 : \star$,
    and similarly there is a derivation of $\nonterm{GC}, \gterm x : \nonterm{tc}_1 \vdash \nonterm{tc}_2 : \star$
    resulting from the other invocation of $\Tranty$.
  \item \textsc{TWF-ADT}.
    \begin{align*}
      & \inferrule{\nonterm G \ctxok \\\\
                   \overline{\nonterm G \vdash \nonterm{ts}_i}^i
                  }
                  {\nonterm G \vdash \langle \overline{l_i : \nonterm{ts}_i}^i \rangle}
          \longmapsto
        \inferrule{\overline{\Tranty(\nonterm G \vdash \nonterm{ts}_i)}^i}
                  {\nonterm{GC} \vdash \langle \overline{l_i : \nonterm{tc}_i}^i \rangle : \star}, \\
      \text{where}~&\nonterm{GC} = \Tranctx(\nonterm G \ctxok),                                         \\
                   &\nonterm{tc}_i = \tranty(\nonterm G \vdash \nonterm{ts}_i).
    \end{align*}

    It can be seen that the right-hand side is well-defined
    by an argument similar to ones for the previous clauses.
\end{itemize}

\paragraph{Terms.}
Finally we define $\Tranterm$.
We consider the term typing rule at the root of the derivation tree for $\nonterm G \vdash \nonterm{es} : \nonterm{ts}$.

\begin{itemize}
  \item \textsc{T-Unit}.
    \begin{align*}
      & \inferrule{\nonterm G \ctxok}
                  {\nonterm G \vdash \unit : \{ \gterm v : \Unit | \top \}}
          \longmapsto
        \inferrule{~}
                  {\nonterm{GC} \vdash \unitc : \Unitc}, \\
      \text{where}~&\nonterm{GC} = \Tranctx(\nonterm G \ctxok).
    \end{align*}
    This rule has a single premise $\nonterm G \ctxok$ that the surface context is well-formed.
    $\Tranctx$ is used to translate the surface derivation of that premise into the core context $\nonterm{GC}$,
    which is then used in \textsc{CT-UnitTerm}.

  \item \textsc{T-Var}.
    \begin{align*}
      & \inferrule{\nonterm G \ctxok \\
                   \gterm x : \nonterm{ts} \in \nonterm G}
                  {\nonterm G \vdash \gterm x : \nonterm{ts}}
          \longmapsto
        \inferrule{x : \nonterm{tc} \in \nonterm{GC}}
                  {\nonterm{GC} \vdash \gterm x : \nonterm{tc}},    \\
      \text{where}~&\nonterm{GC} = \Tranctx(\nonterm G \ctxok),       \\
                   &\nonterm{tc} = \tranty(\nonterm G \vdash \nonterm{ts}).
    \end{align*}

    To show that the right-hand side is well-defined,
    it suffices to show that $x : \nonterm{tc} \in \nonterm{GC}$ holds.

    By definition of $\Tranctx$,
    if $\nonterm G$ contains a binding for the name $x$,
    then $\nonterm{GC}$ also contains a binding for that name,
    and its type is precisely $\tranty(\nonterm G \vdash \nonterm{ts})$.
    Thus, we are allowed to use the (derived) core typing rule \textsc{CT-VarW}.

  \item \textsc{T-Abs}.
    \begin{align*}
      & \inferrule{\nonterm G \vdash (\gterm x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2 \\\\
                   \nonterm G , \gterm x : \nonterm{ts}_1 \vdash \nonterm{es} : \nonterm{ts}_2}
                  {\nonterm G \vdash \lambda x : \nonterm{ts}_1. \nonterm{es} : (\gterm x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2}
          \longmapsto
        \inferrule{\Tranty(\nonterm G \vdash (\gterm x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2) \\\\
                   \Tranterm(\nonterm G , \gterm x : \nonterm{ts}_1 \vdash \nonterm{es} : \nonterm{ts}_2)
                   }
                  {\nonterm{GC} \vdash \lambda x : \nonterm{tc}_1. \nonterm{ec} : \Pi \gterm x : \nonterm{tc}_1. \nonterm{tc}_2},    \\
      \text{where}~&\nonterm{GC} = \Tranctx(\nonterm G \ctxok),       \\
                   &\nonterm{tc}_1 = \tranty(\Gamma \vdash \nonterm{ts}_1), \\
                   &\nonterm{tc}_2 = \tranty(\Gamma , x : \nonterm{ts}_1 \vdash \nonterm{ts}_2), \\
                   &\nonterm{ec} = \tranterm(\nonterm G , \gterm x : \nonterm{ts}_1 \vdash \nonterm{es} : \nonterm{ts}_2).
    \end{align*}

    The right-hand side here is well-formed.
    Firstly, $\Tranty(\nonterm G \vdash (\gterm x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2)$
    produces a derivation tree of the form
    $\nonterm{GC} \vdash \Pi \gterm x : \nonterm{tc}_1. \nonterm{tc}_2 : \star$,
    since the only rule allowing deriving
    $\nonterm G \vdash (\gterm x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2$
    is \textsc{TWF-Arr},
    so it is sufficient to inspect the definition of $\Tranty$ for this rule.
    Then, $\Tranterm(\nonterm G , \gterm x : \nonterm{ts}_1 \vdash \nonterm{es} : \nonterm{ts}_2)$
    produces a derivation of $\nonterm{GC} , \gterm x : \nonterm{tc}_1 \vdash \nonterm{ec} : \nonterm{tc}_2$.
    These two derivations can then be used as premises for \textsc{CT-Abs},
    which is invoked on the right-hand side.

  \item \textsc{T-App}.
    \begin{align*}
      & \inferrule{\nonterm G \vdash \nonterm{es}_1 : (\gterm x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2 \\\\
                   \nonterm G \vdash \nonterm{es}_2 : \nonterm{ts}_1}
                  {\nonterm G \vdash \nonterm{es}_1 \nonterm{es}_2 : [ x \mapsto \nonterm{es}_2 ] \nonterm{ts}_2}
          \longmapsto
        \inferrule{\Tranterm(\nonterm G \vdash \nonterm{es}_1 : (\gterm x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2) \\\\
                   \Tranterm(\nonterm G \vdash \nonterm{es}_2 : \nonterm{ts}_1)
                   }
                  {\nonterm{GC} \vdash \nonterm{ec}_1 \nonterm{ec}_2 : [ x \mapsto \nonterm{ec}_2 ] \nonterm{tc}_2},    \\
      \text{where}~&\nonterm{GC} = \Tranctx(\nonterm G \ctxok),       \\
                   &\nonterm{tc}_2 = \tranty(\Gamma \vdash \nonterm{ts}_2), \\
                   &\nonterm{ec}_1 = \tranterm(\nonterm G \vdash \nonterm{es}_1 : (\gterm x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2), \\
                   &\nonterm{ec}_2 = \tranterm(\nonterm G \vdash \nonterm{es}_2 : \nonterm{ts}_1).
    \end{align*}

    Admissibility of the right-hand side follows from a similar argument.
\end{itemize}

Having defined these functions, we formulate a simple but useful lemma:
\begin{lemma}[Translation totality]
  $\Tranctx$, $\Tranty$ and $\Tranterm$ are total.
\end{lemma}
\begin{proof}
  Firstly, each function is defined for all possible inputs.
  Then, each function recurses on structurally smaller inputs,
  and, since derivation trees are finite,
  this implies each function terminates for any input.
\end{proof}

\subsection{Correctness}

The correctness of the translation hinges on two key theorems.
The first one claims that a well-typed program in surface language remains well-typed after the translation to the core language.
The second one claims that a well-typed surface language program evaluates to ``the same'' value as the translated one.

\begin{theorem}[Well-typedness preservation]
  For any well-typed surface language term $\nonterm{es}$,
  the result of the translation $\tranterm(\nonterm{es})$ is ``equivalently'' typeable in the core language.
\end{theorem}
\begin{proof}
  This follows directly from the definition of $\tranterm$ via $\Tranterm$,
  the latter being total and mapping onto typing derivations in the core language.
\end{proof}

\begin{theorem}[Evaluation equivalence]
  If a well-typed surface language term $\nonterm{es}$ evaluates to v, then $\tranterm(\nonterm{es})$ evaluates to $\tranterm(v)$:
  %TODO symbols and all that for v
\end{theorem}
\begin{proof}
\end{proof}

\bibliographystyle{babunsrt-lf}
\bibliography{biblio}

\end{document}
