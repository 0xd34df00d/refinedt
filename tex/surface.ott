%%% Surface language

grammar
es {{ tex \nonterm{es} }} :: tmS_ ::= {{ com terms }}
  | x				::   :: var {{ com variable }}
  | v				::   :: refvar {{ com refinement var }}
  | n				::   :: int {{ com integer }}
  | if es1 then es2 else es3
					::   :: ite {{ com conditional }}
  | \ x : ts . es	::   :: abs {{ com abstraction }}
  | es1 es2			::   :: app {{ com application }}
  | top				::   :: true {{ com true }}
  | bot				::   :: false {{ com false }}
  | [ v |-> es' ] es	:: M :: evsubst

r {{ tex \nonterm r }} :: ref_ ::= {{ com refinements }}
  | top				:: M :: top {{ com top }}
  | es1 = es2		::   :: rexpr {{ com atomic refinement }}
  | r1 /\ r2		::   :: rconj {{ com conjunction }}

B {{ tex \nonterm B }} :: tbasep_ ::= {{ com base types }}
  | Int				::   :: bInt
  | Bool			::	 :: bBool

ts {{ tex \nonterm{ts} }} :: ts_ ::= {{ com types }}
  | { v : B | r }		::   :: tybase {{ com refined base type }}
  | { _ : B | r }		:: M :: irrelevant {{ com var-irrelevant refined base type }}
  | ( x : ts1 ) -> ts2	::   :: tyarr  {{ com arrow type }}
  | [ x |-> es ] ts		:: M :: txsubst

G {{ tex \nonterm G }} :: env_ ::= {{ com typing contexts }}
  | empty			::   :: nil {{ com empty }}
  | G , x : ts		::   :: var {{ com variable }}

L {{ tex \nonterm L }} :: logic_pred_ ::= {{ com logical predicate }}
  | es1 = es2		::   :: termEq {{ com term equality }}
  | A v . L			::   :: forall {{ com $\forall$ }}
  | ( L )			:: M :: parens {{ com parenthesizing }}
  | r1 => r2		::   :: impl   {{ com implication }}

C {{ tex \nonterm C }} :: logic_ctx_ ::= {{ com logical context }}
  | empty			::   :: nil
  | C, L			::   :: pred
  | '[|' G '|]'		:: M :: ctx

defns Jtype :: '' ::=

defn G |- ts :: :: type_wf :: TWF_ {{ com type well-formedness }} by

-------------------- :: TrueRef
G |- { v : B | top }

G , x : { v : B | top } |- [v |-> x] es1 : { v : Bool | r1 }
G , x : { v : B | top } |- [v |-> x] es2 : { v : Bool | r2 }
x fresh
-------------------------------------------------- :: Base
G |- { v : B | es1 = es2 }

G |- { v : B | r1 }
G |- { v : B | r2 }
------------------------- :: Conj
G |- { v : B | r1 /\ r2 }

G |- ts1
G, x : ts1 |- ts2
--------------------- :: Arr
G |- (x : ts1) -> ts2


defn G |- es : ts :: :: typing :: T_ {{ com term typing }} by

x : ts in G
---------- :: Var
G |- x : ts

--------------------------- :: BoolTop
G |- top : { v : Bool | top }

--------------------------- :: BoolBot
G |- bot : { v : Bool | top }

G |- ( x : ts1 ) -> ts2
G |- es1 : ( x : ts1 ) -> ts2
G |- es2 : ts1
-------------------------- :: App
G |- es1 es2 : [ x |-> es2] ts2

G , x : ts1 |- es : ts2
------------------------------------- :: Abs
G |- \x : ts1. es : ( x : ts1 ) -> ts2

G |- es1 : { v : Bool | r }
G , x : { _ : Bool | es1 = top } |- es2 : ts
G , x : { _ : Bool | es1 = bot } |- es3 : ts
x fresh
------------------------------------- :: If
G |- if es1 then es2 else es3 : ts

G |- es : ts
G |- ts' <: ts
------------ :: Sub
G |- es : ts'


defn G |- ts1 <: ts2 :: :: subtyping :: ST_ {{ com subtyping }} by

[| G |] => A v. (r1 => r2)
------------------------------------- :: Base
G |- { v : B | r1 } <: { v : B | r2 }


G |- ts1' <: ts1
G , x : ts1 |- ts2 <: ts2'
--------------------------------------- :: Arr
G |- (x : ts1) -> ts2 <: (x : ts1') -> ts2'


grammar
metavar x {{ tex \gterm x }} ::= {{ com variables }}
metavar v {{ tex \gterm v }} ::= {{ com refinement variables }}
metavar n {{ tex \gterm n }} ::= {{ com integers }}

grammar
formula :: formula_ ::=
  | judgement	:: :: judgement
  | x : ts in G :: :: xinenv
  | es = T		:: :: eTrue
  | es = F		:: :: eFalse
  | C => L		:: :: implication
  | ec =b ec2	:: :: betaconversion
  | x fresh		:: :: freshness

terminals :: terminals_ ::=
  | top		:: :: top {{ tex \top }}
  | bot		:: :: bot {{ tex \bot }}
  | /\      :: :: and {{ tex \land }}
  | ->      :: :: arr {{ tex \rightarrow }}
  | |->     :: :: subst {{ tex \mapsto }}
  | in		:: :: in  {{ tex \in }}
  | |-		:: :: proves {{ tex \vdash }}
  | \       :: :: lambda {{ tex \lambda }}
  | Pi		:: :: product {{ tex \Pi }}
  | <:		:: :: subtype {{ tex \mathrel{<:} }}
  | A		:: :: forall {{ tex \forall }}
  | =>		:: :: implies {{ tex \implies }}
  | sst		:: :: starkind {{ tex \star }}
  | ssq		:: :: squarekind {{ tex \square }}
  | empty   :: :: empty {{ tex \emptyset }}
  | =b		:: :: beq {{ tex =_\beta }}
  | fresh	:: :: fresh {{ tex \text{fresh name} }}


%%% Core language

grammar
ec {{ tex \nonterm{ec} }} :: tmCore_ ::= {{ com expressions }}
  | x					::   :: var {{ com variable }}
  | s					::   :: sort {{ com sort }}
  | Pi x : ec1 . ec2	::   :: piabs {{ com $\Pi$-type }}
  | \ x : ec1 . ec2		::   :: lamabs {{ com abstraction }}
  | ec1 ec2				::   :: app {{ com application }}
  | Bool				::   :: bool {{ com base bool type }}
  | Int					::   :: int {{ com base int type }}
  | [ x |-> ec1 ] ec2		:: M :: subst

s {{ tex \nonterm{s} }} :: s_ ::= {{ com sorts }}
  | sst				::   :: type {{ com types }}
  | ssq				::   :: kind {{ com kinds }}

GC {{ tex \nonterm{GC} }} :: coreenv_ ::=
  | empty			:: :: nil
  | GC , x : ec		:: :: var

defns Jderiv :: '' ::=

defn GC |- ec1 : ec2 :: :: coretyping :: CT_ {{ com typing }} by

------------------ :: Sort
empty |- sst : ssq

GC |- ec : s
--------------------- :: Var
GC , x : ec |- x : ec

GC |- ec1 : ec2
GC |- ec3 : s
------------------------- :: Weaken
GC , x : ec3 |- ec1 : ec2

GC |- ec1 : s1
GC , x : ec1 |- ec2 : s2
--------------------------- :: Form
GC |- Pi x : ec1 . ec2 : s2

GC |- ec1' : Pi x : ec1 . ec2
GC |- ec2' : ec1
----------------------------- :: App
GC |- ec1' ec2' : [ x |-> ec1 ] ec2

GC , x : ec1 |- ec : ec2
GC |- Pi x : ec1 . ec2 : s
----------------------------- :: Abs
GC |- \ x : ec1 . ec : Pi x : ec1 . ec2

GC |- ec : ec1
GC |- ec2 : s
ec1 =b ec2
-------------- :: Conv
GC |- ec : ec2
