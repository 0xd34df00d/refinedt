%%% Surface language

grammar
eS {{ tex \nonterm{eS} }} :: tmS_ ::= {{ com terms }}
  | x				::   :: var {{ com variable }}
  | v				::   :: refvar {{ com refinement var }}
  | n				::   :: int {{ com integer }}
  | if eS1 then eS2 else eS3
					::   :: ite {{ com conditional }}
  | \ x : tS . eS	::   :: abs {{ com abstraction }}
  | eS1 eS2			::   :: app {{ com application }}
  | top				::   :: true {{ com true }}
  | bot				::   :: false {{ com false }}

r {{ tex \nonterm r }} :: ref_ ::= {{ com refinements }}
  | eS				::   :: rexpr {{ com atomic refinement }}
  | r1 /\ r2		::   :: rconj {{ com conjunction }}

B {{ tex \nonterm B }} :: tbasep_ ::= {{ com base types }}
  | Int				::   :: bInt
  | Bool			::	 :: bBool

tS {{ tex \nonterm{tS} }} :: tS_ ::= {{ com types }}
  | { v : B | r }		::   :: tybase {{ com refined base type }}
  | { v : tS | r }		:: M :: tyref {{ com refined base type }}
  | ( x : tS1 ) -> tS2	::   :: tyarr  {{ com arrow type }}
  | { eS / x } tS		:: M :: tsubst

G {{ tex \nonterm G }} :: env_ ::=
  | empty			::   :: nil
  | G , x : tS		::   :: var
  | G , v : tS		::   :: refvar
  | G , L			::   :: logical

L {{ tex \nonterm L }} :: logic_pred_ ::= {{ com logical predicate }}
  | eS1 = eS2		::   :: termEq {{ com term equality }}
  | A v . L			::   :: forall {{ com $\forall$ }}
  | ( L )			:: M :: parens {{ com parenthesizing }}
  | r1 => r2		::   :: impl   {{ com implication }}

C {{ tex \nonterm C }} :: logic_ctx_ ::= {{ com logical context }}
  | empty			::   :: nil
  | C, L			::   :: pred
  | '[|' G '|]'		:: M :: ctx

defns Jtype :: '' ::=

defn G |- tS :: :: type_wf :: TWF_ {{ com type well-formedness }} by

-------------------- :: TrueRef
G |- { v : tS | top }

G , v : { v' : tS | top } |- eS : { v : Bool | r }
----------------------------------------------- :: Base
G |- { v : tS | eS }

G |- { v : tS | r1 }
G |- { v : tS | r2 }
------------------------- :: Conj
G |- { v : tS | r1 /\ r2 }

G |- tS1
G, x : tS1 |- tS2
--------------------- :: Arr
G |- (x : tS1) -> tS2


defn G |- eS : tS :: :: typing :: T_ {{ com term typing }} by

x : tS in G
---------- :: Var
G |- x : tS

--------------------------- :: BoolTop
G |- top : { v : Bool | top }

--------------------------- :: BoolBot
G |- bot : { v : Bool | top }

G |- ( x : tS1 ) -> tS2
G |- eS1 : ( x : tS1 ) -> tS2
G |- eS2 : tS1
-------------------------- :: App
G |- eS1 eS2 : {eS2/x}tS2

G , x : tS1 |- eS : tS2
------------------------------------- :: Abs
G |- \x : tS1. eS : ( x : tS1 ) -> tS2

G |- eS1 : { v : Bool | r }
G , eS1 = top |- eS2 : tS
G , eS1 = bot |- eS3 : tS
------------------------------------- :: If
G |- if eS1 then eS2 else eS3 : tS

G |- eS : tS
G |- tS' <: tS
------------ :: Sub
G |- eS : tS'


defn G |- tS1 <: tS2 :: :: subtyping :: ST_ {{ com subtyping }} by

[| G |] => A v. (r1 => r2)
------------------------------------- :: Base
G |- { v : B | r1 } <: { v : B | r2 }


G |- tS1' <: tS1
G , x : tS1 |- tS2 <: tS2'
--------------------------------------- :: Arr
G |- (x : tS1) -> tS2 <: (x : tS1') -> tS2'


grammar
metavar x {{ tex \gterm x }} ::= {{ com variables }}
metavar v {{ tex \gterm v }} ::= {{ com refinement variables }}
metavar n {{ tex \gterm n }} ::= {{ com integers }}

grammar
formula :: formula_ ::=
  | judgement	:: :: judgement
  | x : tS in G :: :: xinenv
  | eS = T		:: :: eTrue
  | eS = F		:: :: eFalse
  | C => L		:: :: implication
  | ec =b ec2	:: :: betaconversion

terminals :: terminals_ ::=
  | top		:: :: top {{ tex \top }}
  | bot		:: :: bot {{ tex \bot }}
  | /\      :: :: and {{ tex \land }}
  | ->      :: :: arr {{ tex \rightarrow }}
  | in		:: :: in  {{ tex \in }}
  | |-		:: :: proves {{ tex \vdash }}
  | \       :: :: lambda {{ tex \lambda }}
  | Pi		:: :: product {{ tex \Pi }}
  | <:		:: :: subtype {{ tex \mathrel{<:} }}
  | A		:: :: forall {{ tex \forall }}
  | =>		:: :: implies {{ tex \implies }}
  | sst		:: :: starkind {{ tex \star }}
  | ssq		:: :: squarekind {{ tex \square }}
  | empty   :: :: empty {{ tex \emptyset }}
  | =b		:: :: beq {{ tex =_\beta }}


%%% Core language

grammar
ec {{ tex \nonterm{ec} }} :: tmCore_ ::= {{ com expressions }}
  | x					::   :: var {{ com variable }}
  | s					::   :: sort {{ com sort }}
  | Pi x : ec1 . ec2	::   :: piabs {{ com $\Pi$-type }}
  | \ x : ec1 . ec2		::   :: lamabs {{ com abstraction }}
  | ec1 ec2				::   :: app {{ com application }}
  | Bool				::   :: bool {{ com base bool type }}
  | Int					::   :: int {{ com base int type }}
  | { ec1 / x } ec2		:: M :: subst

s {{ tex \nonterm{s} }} :: s_ ::= {{ com sorts }}
  | sst				::   :: type {{ com types }}
  | ssq				::   :: kind {{ com kinds }}

GC {{ tex \nonterm{GC} }} :: coreenv_ ::=
  | empty			:: :: nil
  | GC , x : ec		:: :: var

defns Jderiv :: '' ::=

defn GC |- ec1 : ec2 :: :: coretyping :: CT_ {{ com typing }} by

------------------ :: Sort
empty |- sst : ssq

GC |- ec : s
--------------------- :: Var
GC , x : ec |- x : ec

GC |- ec1 : ec2
GC |- ec3 : s
------------------------- :: Weaken
GC , x : ec3 |- ec1 : ec2

GC |- ec1 : s1
GC , x : ec1 |- ec2 : s2
--------------------------- :: Form
GC |- Pi x : ec1 . ec2 : s2

GC |- ec1' : Pi x : ec1 . ec2
GC |- ec2' : ec1
----------------------------- :: App
GC |- ec1' ec2' : {ec1/x}ec2

GC , x : ec1 |- ec : ec2
GC |- Pi x : ec1 . ec2 : s
----------------------------- :: Abs
GC |- \ x : ec1 . ec : Pi x : ec1 . ec2

GC |- ec : ec1
GC |- ec2 : s
ec1 =b ec2
-------------- :: Conv
GC |- ec : ec2
