\documentclass[a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{ottalt}
\usepackage{subcaption}
\usepackage{cite,url,babelbib}
\usepackage[english]{babel}

\addtolength{\topmargin}{-1.05in}
\addtolength{\textheight}{1.55in}

\newtheorem{theorem}{Theorem}

\newcommand{\unit}{u}
\newcommand{\Unit}{\textbf{Unit}}
\newcommand{\unitc}{\hat{u}}
\newcommand{\Unitc}{\widehat{\textbf{Unit}}}
\newcommand{\Int}{\textbf{Int}}

\begin{document}

\newNTclass{nonterm}
\newnonterm e \varepsilon
\newnonterm{es}{\varepsilon}
\newnonterm{ec}{\hat\varepsilon}
\newnonterm r \rho
\newnonterm{ts}{\tau}
\newnonterm s s
\newnonterm l l
\newnonterm B B
\newnonterm G \Gamma
\newnonterm{GC}{\hat\Gamma}
\newnonterm{binop}{\odot}

\newNTclass{gterm}
\newgterm x x
\newgterm v v
\newgterm n n

\newcommand{\figref}[1]{Figure \ref{fig:#1}}

\inputott{surface.ott}

\title{Compiling refinement types to dependent types}

\maketitle

\section{Introduction}

\section{Overview}

%TODO describe the notion of the oracle (like an SMT solver) and what we expect of the oracle.

\section{Calculi definitions}

\subsection{Surface language}

Our surface language is based on simply typed lambda calculus.
Refinements over the types are, of course, the most important extension.
The other ones are:
\begin{itemize}
  \item dependent arrow types, to allow subsequent refinements refer preceding arguments,
  \item limited form of algebraic data types and dependent pattern matching
    insired by \cite{TAPLVariants,Eisenberg16},
    to illustrate reasoning about those widely used constructs.
\end{itemize}

The syntax of the surface language is presented in \figref{surface_syntax}.

The typing rules for the surface language are laid out in \figref{surface_typing}.
For the type well-formedness and term typing rules
we also assume each of them has a premise $\nonterm G \text{ ok}$
stating that the context is well-formed.

\begin{figure}[ht]
  \footnotesize
  \begin{subfigure}{.6\textwidth}
    \nonterms{es,l}
    \caption{Term level}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
    \nonterms{G,r,B,ts}
    \caption{Type level}
  \end{subfigure}
  \caption{Surface language syntax}
  \label{fig:surface_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[TCTX]{$\nonterm G \text{ ok}$}{context well-formedness}{Empty,Bind}
  \drules[TWF]{$\nonterm G \vdash \nonterm{ts}$}{type well-formedness}{TrueRef,Base,Conj,Arr}
  \drules[T]{$\nonterm G \vdash \nonterm{es} : \nonterm{ts}$}{term typing}{Unit,Var,Abs,App,Case,Con,Sub}
  \drules[ST]{$\nonterm G \vdash \nonterm{ts}_1 <: \nonterm{ts}_2$}{subtyping}{Base,Arr}
  \caption{Surface language typing}
  \label{fig:surface_typing}
\end{figure}


We introduce a shorthand notation $\top$ denoting some tautology
which we use for trivial refinements that do not carry any extra information.
In particular, one good way to define $\top$ is
to state the equality of the sole inhabitant of $\Unit$ to itself:
$\top \triangleq \unit = \unit$.

The surface language might also have other base types (for example, $\Int$),
elements of syntax (like numbers and operations on them)
as well as typing rules relating those,
but we omit them for the sake of brevity.

We also have the following concessions:
\begin{itemize}
  \item The syntax only allows refinements on base types.
    Note that this does not restrict the expressive power of the language.
    For instance, a refinement on a function that we might otherwise wish to write as
    \[
      (x : \Int) \rightarrow \{ v : \Int \rightarrow \Int | v x = 0 \} \rightarrow \Int
    \]
    might instead be expressed via a dummy parameter:
    \[
      (x : \Int) \rightarrow (f : \Int \rightarrow \Int) \rightarrow \{ \_ : \Unit | f x = 0 \} \rightarrow \Int.
    \]
  \item Our algebraic data types only allow a single ``field'' in each constructor.
    One way to alleviate this is to introduce tuples,
    but doing so would complicate the exposition
    without any benefit for illustrating the main idea of this work.
\end{itemize}

The translation function $[|\ |]$ maps the typing context $\nonterm G$ to some logic
that the oracle can handle.
It might be defined as follows:
\begin{equation}
\begin{aligned}
  & [|\ \emptyset\ |]                                         && \triangleq && \top																						            \\
  & [|\ \nonterm G, x : \{ v : \nonterm B | \nonterm r \}\ |] && \triangleq && [|\ \nonterm G\ |] \land [|\ [ v \mapsto x ] \nonterm r\ |]  \\
  & [|\ \nonterm r_1 \land \nonterm r_2\ |]                   && \triangleq && [|\ \nonterm r_1\ |] \land [|\ \nonterm r_2\ |]              \\
  & [|\ \nonterm{es}_1 = \nonterm{es}_2\ |]                   && \triangleq && \text{oracle}(\nonterm{es}_1 = \nonterm{es}_2)             \\
\end{aligned}
\end{equation}

The last equation represents the assumption
that the oracle knows how to translate the atomic refinements.

%TODO define substitutions on the \nonterm r

In the subsequent text we also assume the oracle can decide the resulting proposition
(otherwise it might be left as a separate lemma to be filled out by the user in the core language, or rejected altogether).

\subsection{Core language}

We take $\lambda C$ \cite{TTFPLambdaC}
with a unit type as our core dependently typed language.
We conjecture that the introduction of units
does not break the usual metatheoretical properties of the system.

The syntax of the core language is presented in \figref{core_syntax},
and the typing rules are defined in \figref{core_typing}.

\begin{figure}[ht]
  \footnotesize
  \nonterms{ec,s}
  \caption{Core language syntax}
  \label{fig:core_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[CT]{$\nonterm G \vdash \nonterm{ec}_1 : \nonterm{ec}_2$}{core typing}{Sort,UnitType,UnitTerm,Var,Weaken,Form,App,Abs,Conv}
  \caption{Core language typing rules}
  \label{fig:core_typing}
\end{figure}

Although the syntax doesn't mention $\tau$, we will use it as a metavariable
where a type (an inhabitant of $\star$) is expected.

\newcommand{\dast}{\ **\ }

We also establish some derived forms in the core language to simplify the subsequent exposition:

\begin{itemize}
  \item Non-dependent function type:
    \[
      \tau_1 \rightarrow \tau_2 \triangleq \Pi \_ : \tau_1. \tau_2.
    \]
  \item Dependent pair type, or $\Sigma$-type, with the first component being a value $x$ of type $\tau$ and the second component being of type $P x$:
    \[
      (x : \tau \dast P x) \triangleq \Pi \alpha : \star. (\Pi x : \tau. P x \rightarrow \alpha) \rightarrow \alpha,
    \]
    with the corresponding constructor (we overload the syntax here to resemble Idris):
    \[
      (x \dast p) \triangleq \lambda \alpha : \star. \lambda f : (\Pi x' : \tau. P x' \rightarrow \alpha). f x p
    \]
    and projections
    \[
      \text{fst} \triangleq \lambda \sigma : (x : \tau \dast P x). \sigma \tau (\lambda x' : \tau. \lambda \_ : P x'. x'),
    \]
    \[
      \text{snd} \triangleq \lambda \sigma : (x : \tau \dast P x). \sigma \tau (\lambda x' : \tau. \lambda p : P x'. p).
    \]
  \item Non-dependent pair type:
    \[
      (\tau_1, \tau_2) \triangleq \{ x : \tau_1\ **\ (\lambda \_ : \tau_1. \tau_2) x \}.
    \]
  \item Equality of expressions $\nonterm{ec}_1, \nonterm{ec}_2$ of type $S$:
    \[
      \nonterm{ec}_1 \equiv \nonterm{ec}_2 \triangleq \Pi P : S \rightarrow \star. (P x \rightarrow P y, P y \rightarrow P x).
    \]
    The reader might recognize this as the Leibniz equality \cite{FindSomethingForThis}.
  \item ADTs, expressed using an encoding similar to Boehm-Berarducci's \cite{Bohm85}.
    We borrow the syntax for the ADTs from the surface language and put a hat on it,
    so let's take some ADT $\widehat{\langle \overline{l_i : \nonterm{ts}_i}^i \rangle}$.
    The usual Boehm-Berarducci encoding associates the type
    $\Pi \alpha : \star. \overline{(\nonterm{ts}_i \rightarrow \alpha)}^i \rightarrow \alpha$ with it.

    We go a step further to account for the subset of the dependent pattern matching
    that we are interested in.

    First, each label $l_i$ gives rise to a term $\hat{l_i}$ of type $\nonterm{ts}_i \rightarrow \xi$.
    %TODO operational semantics?
    We then define the derived form
    \[
      \widehat{\langle \overline{l_i : \nonterm{ts}_i}^i \rangle}
        \triangleq
          \Pi s : \xi.
          \Pi \alpha : \star.
          \overline{(\Pi x_i : \nonterm{ts}_i. s \equiv \hat{l_i} x_i \rightarrow \alpha)}^i \rightarrow \alpha.
    \]
    The outer extra argument named $s$ denotes the scrutinee of the case expression to be defined next.
    The inner extra argument with the type $s \equiv \hat{l_i} x_i$
    expresses the subset of dependent pattern matching
    that we rely on for the translation from the surface language:
    in particular, it provides the ``case branch'' with a proof
    that the scrutinee $s$ is indeed equal to the ``case pattern'' $\hat{l_i} x_i$.
\end{itemize}

\section{Translation}

\newcommand{\tranctx}{\mu_\Gamma}
\newcommand{\tranty}{\mu_\tau}
\newcommand{\tranterm}{\mu_\varepsilon}

\newcommand{\Tranctx}{\mu_{\vdash\Gamma}}
\newcommand{\Tranty}{\mu_{\vdash\tau}}
\newcommand{\Tranterm}{\mu_{\vdash\varepsilon}}

We translate the surface language contexts, types and terms into the corresponding core language entities
using the $\tranctx$, $\tranty$ and $\tranterm$ functions respectively,
which are defined mutually recursively.

Before we dive into defining these functions, $\Tranterm$ deserves a few introductory words.
Although the aim is to translate terms,
what this function really does is translating the surface typing derivation for a given (well-typed) term
into a typing derivation in the core language.
The reason for the extra complexity stems from the \ranchor{T-Sub} typing rule.
In particular, this rule invokes the subtyping check, which, in turn, invokes the oracle.
The oracle then might produce a core language term proving that the subtyping relation in question holds,
and the presence of this rule is in some sense a carrier of this proof term.

\paragraph{Contexts.}
We start with defining $\tranctx$,
which merely translates the types of the bindings in the context from the surface language into the core language:
\begin{equation}
\begin{aligned}
  & \tranctx(\emptyset)                                       && \triangleq \emptyset                                               \\
  & \tranctx(\nonterm G, \gterm x : \nonterm{ts})             && \triangleq \tranctx(\nonterm G), \gterm x : \tranty(\nonterm{ts})  \\
\end{aligned}
\end{equation}

\paragraph{Types.}
$\tranty$ is defined as follows,
with the slight abuse of notation to allow ``recursive'' calls
on the refinement part of the surface language syntax:
\begin{equation}
\begin{aligned}
  & \tranty( (x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2)  && \triangleq \Pi x : \tranty(\nonterm{ts}_1). \tranty(\nonterm{ts}_2)     \\
  & \tranty( \{ v : \nonterm{ts} | \nonterm{r} \})             && \triangleq \{ v : \tranty(\nonterm{ts})\ **\ \tranty(\nonterm r) \}     \\
  & \tranty( \nonterm r_1 \land \nonterm r_2 )                 && \triangleq ( \tranty(\nonterm r_1) , \tranty(\nonterm r_2))             \\
  & \tranty( \nonterm{es}_1 = \nonterm{es}_2 )                 && \triangleq \tranterm(\nonterm{es}_1) \equiv \tranterm(\nonterm{es}_2)   \\
  & \tranty(B)                                                 && \triangleq B                                                            \\
%TODO this last one is not well-defined
\end{aligned}
\end{equation}
Or, in words:
\begin{itemize}
  \item (dependent) arrow types are translated to the corresponding $\Pi$-types,
  \item refined types are translated to the corresponding $\Sigma$-types,
  \item atomic refinements, being propositions about surface language terms equality,
    are translated to propositions stating the equality of translated core language terms,
  \item conjunctions of several (atomic) refinements are represented as tuples of the corresponding atomic translations.
\end{itemize}

\paragraph{Terms.}
Finally we define $\Tranterm$.
We consider the term typing rule that is at the root of the derivation tree for $\nonterm G \vdash \nonterm{es} : \nonterm{ts}$.

\begin{itemize}
  \item \ranchor{T-Unit}.
    \begin{align*}
      & \inferrule{\nonterm G \text{ ok}}{\nonterm G \vdash \unit : \{ \gterm v : \Unit | \top \}}
          \longmapsto
        \inferrule{ }{\nonterm{GC} \vdash \unitc : \Unitc}, \\
      \text{where}~&\nonterm{GC} = \tranctx(\nonterm G \text{ ok}).
    \end{align*}
    This rule has a single premise $\nonterm G \text{ ok}$ that the surface context is well-formed.
    We use $\Tranctx$ to translate the surface derivation of that premise into the core one,
    and extract the resulting context $\nonterm{GC}$.
    We then use that context for \ranchor{CT-UnitTerm}.
\end{itemize}

\subsection{Correctness}

The correctness of the translation hinges on two key theorems.
The first one claims that a well-typed program in surface language remains well-typed after the translation to the core language.
The second one claims that a well-typed surface language program evaluates to ``the same'' value as the translated one.

\begin{theorem}[Well-typedness preservation]
  For any well-typed surface language term $\nonterm{es}$,
  the result of the translation $\tranterm(\nonterm{es})$ is ``equivalently'' typeable in the core language:
  \[
    \nonterm G \vdash \nonterm{es} : \nonterm{ts} \implies \tranctx(\nonterm G) \vdash \tranterm(\nonterm{es}) : \tranty(\nonterm{ts})
  \]
\end{theorem}
\begin{proof}
  We prove this by induction on the derivation of the typeability of $\nonterm{es}$.
  In particular, we consider the last typing rule used:
\end{proof}

\begin{theorem}[Evaluation equivalence]
  If a well-typed surface language term $\nonterm{es}$ evaluates to v, then $\tranterm(\nonterm{es})$ evaluates to $\tranterm(v)$:
  %TODO symbols and all that for v
\end{theorem}
\begin{proof}
\end{proof}

\bibliographystyle{babunsrt-lf}
\bibliography{biblio}

\end{document}
