\documentclass[a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{ottalt}
\usepackage{subcaption}
\usepackage{cite}

\addtolength{\topmargin}{-1.05in}
\addtolength{\textheight}{1.55in}

\newtheorem{theorem}{Theorem}

\begin{document}

\newNTclass{nonterm}
\newnonterm e \varepsilon
\newnonterm{es}{\varepsilon}
\newnonterm{ec}{\overline\varepsilon}
\newnonterm r \rho
\newnonterm{ts}{\tau}
\newnonterm s s
\newnonterm B B
\newnonterm G \Gamma
\newnonterm{GC}{\overline\Gamma}
\newnonterm{binop}{\odot}

\newNTclass{gterm}
\newgterm x x
\newgterm v v
\newgterm n n

\inputott{surface.ott}

\title{Compiling refinement types to dependent types}

\maketitle

\section{Introduction}

\section{Overview}

\section{Calculi definitions}

\subsection{Surface language}

\begin{figure}[ht]
  \footnotesize
  \begin{subfigure}{.6\textwidth}
	\nonterms{es}
	\caption{Term level}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
	\nonterms{r,B,ts}
	\caption{Type level}
  \end{subfigure}
  \caption{Surface language syntax}
  \label{fig:surface_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[TWF]{$\nonterm G \vdash \nonterm{ts} \text{ ok}$}{type well-formedness}{TrueRef,Base,Conj,Arr}
  \drules[T]{$\nonterm G \vdash \nonterm{es} : \nonterm{ts}$}{term typing}{BoolTop,BoolBot,Var,Abs,App,If,Sub}
  \drules[ST]{$\nonterm G \vdash \nonterm{ts}_1 <: \nonterm{ts}_2$}{subtyping}{Base,Arr}
  \caption{Surface language typing rules}
  \label{fig:surface_typing}
\end{figure}

The translation function $[|\ |]$ maps the typing context $\nonterm G$ to some logic:
\begin{equation}
\begin{aligned}
  & [| \emptyset |]                                         && \triangleq && \top																						  \\
  & [| \nonterm G, x : \{ v : \nonterm B | \nonterm r \} |] && \triangleq && [| \nonterm G |] \land [| \{x/v\} \nonterm r |]  \\
  & [| \nonterm r_1 \land \nonterm r_2 |]                   && \triangleq && [| \nonterm r_1 |] \land [| \nonterm r_2 |]      \\
  & [| \nonterm{es} |]                                      && \triangleq && \text{oracle}(\nonterm{es})                      \\
  & [| \nonterm{es}_1 = \nonterm{es}_2 |]                   && \triangleq && \text{oracle}(\nonterm{es}_1 = \nonterm{es}_2)   \\
\end{aligned}
\end{equation}

The last two equations represent the assumption
that the oracle knows how to translate the elementary refinements being the terms $\nonterm{es}$
or equality propositions $\nonterm{es}_1 = \nonterm{es}_2$.

%TODO define substitutions on the \nonterm r

In the subsequent text we also assume the oracle can decide the resulting proposition
(otherwise it might be left as a separate lemma to be filled out by the user in the core language, or rejected altogether).

\subsection{Core language}

We take $\lambda C$ \cite{Nederpelt14} enriched with integers and case-splitting as our core dependently typed language.

\begin{figure}[ht]
  \footnotesize
  \nonterms{ec,s}
  \caption{Core language syntax}
  \label{fig:core_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[CT]{$\nonterm G \vdash \nonterm{ec}_1 : \nonterm{ec}_2$}{core typing}{Sort,Var,Weaken,Form,App,Abs,Conv}
  \caption{Core language typing rules}
  \label{fig:core_typing}
\end{figure}

We also establish some derived entities in the core language to simplify the subsequent exposition:

\begin{itemize}
  \item Non-dependent function type:
  \[
    \tau_1 \rightarrow \tau_2 \triangleq \Pi \_ : \tau_1. \tau_2.
  \]
  \item Dependent pair type, or $\Sigma$-type, with the first component being a value $x$ of type $\tau$ and the second component being of type $P x$:
  \[
    \{ x : \tau\ **\ P x \} \triangleq \Pi \alpha : \star. (\Pi x : \tau. P x \rightarrow \alpha) \rightarrow \alpha.
  \]
  \item Accessing the first and second component of the dependent pair:
  \[
    \text{fst} \triangleq TODO,
  \]
  \[
    \text{snd} \triangleq TODO.
  \]
  \item Non-dependent pair type:
  \[
    (\tau_1, \tau_2) \triangleq \{ x : \tau_1\ **\ (\lambda \_ : \tau_1. \tau_2) x \}.
  \]
\end{itemize}

\section{Translation}

We translate the surface language types and terms using the $\mu_\tau$ and $\mu_\varepsilon$ functions respectively.
$\mu_\tau$ is defined as follows:
\begin{equation}
\begin{aligned}
  & \mu_\tau( (x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2)  && \triangleq \Pi x : \mu_\tau(\nonterm{ts}_1). \mu_\tau(\nonterm{ts}_2)  \\
  & \mu_\tau( \{ v : \nonterm{ts} | \nonterm{r} \})             && \triangleq \{ v : \mu_\tau(\nonterm{ts})\ **\ \mu_\tau(\nonterm r) \}  \\
  & \mu_\tau( \nonterm r_1 \land \nonterm r_2 )                 && \triangleq ( \mu_\tau(\nonterm r_1) , \mu_\tau(\nonterm r_2))          \\
  & \mu_\tau( \nonterm{es} )                                    && \triangleq \mu_\varepsilon(\nonterm{es}) = \text{True}                 \\
  & \mu_\tau(B)                                                 && \triangleq B                                                           \\
\end{aligned}
\end{equation}
Or, in words:
\begin{itemize}
  \item (dependent) arrow types are translated to the corresponding $\Pi$-types,
  \item refined types are translated to the corresponding $\Sigma$-types,
  \item atomic refinements (which are $\text{Bool}$-typed terms) are translated to propositions stating that the corresponding term is equal to $\text{True}$,
  \item conjunctions of several (atomic) refinements are represented as tuples of the corresponding atomic translations.
\end{itemize}

%TODO define translation for gammas

\subsection{Correctness}

We next formulate our key theorem:

\theorem For any well-typed surface language term $\nonterm{es}$, the result of the translation $\mu_\epsilon(\nonterm{es})$ is well-typed in the core language:
\[
  \nonterm G \vdash \nonterm{es} : \nonterm{ts} \implies \mu_\Gamma(\nonterm G) \vdash \mu_\epsilon(\nonterm{es}) : \mu_\tau(\nonterm{ts})
\]

\end{document}
