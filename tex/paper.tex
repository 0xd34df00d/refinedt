\documentclass[a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amsfonts}
\usepackage{xcolor}
\usepackage{ottalt}
\usepackage{subcaption}

\addtolength{\topmargin}{-1.75in}
\addtolength{\textheight}{2.75in}

\begin{document}

\newNTclass{nonterm}
\newnonterm e \varepsilon
\newnonterm{eS}{\varepsilon}
\newnonterm{ec}{\overline\varepsilon}
\newnonterm r \rho
\newnonterm{tS}{\tau}
\newnonterm{tC}{\overline\tau}
\newnonterm s s
\newnonterm B B
\newnonterm G \Gamma
\newnonterm{GC}{\overline\Gamma}
\newnonterm{binop}{\odot}

\newNTclass{gterm}
\newgterm x x
\newgterm v v
\newgterm n n

\inputott{surface.ott}

\title{Compiling refinement types to dependent types}

\maketitle

\section{Introduction}

\section{Overview}

\section{Calculi definitions}

\subsection{Surface language}

\begin{figure}[ht]
  \footnotesize
  \begin{subfigure}{.6\textwidth}
	\nonterms{eS}
	\caption{Term level}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
	\nonterms{r,B,tS}
	\caption{Type level}
  \end{subfigure}
  \caption{Surface language syntax}
  \label{fig:surface_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[TWF]{$\nonterm G \vdash \nonterm{tS} \text{ ok}$}{type well-formedness}{TrueRef,Base,Conj,Arr}
  \drules[T]{$\nonterm G \vdash \nonterm{eS} : \nonterm{tS}$}{term typing}{BoolTop,BoolBot,Var,Abs,App,If,Sub}
  \drules[ST]{$\nonterm G \vdash \nonterm{tS}_1 <: \nonterm{tS}_2$}{subtyping}{Base,Arr}
  \caption{Surface language typing rules}
  \label{fig:surface_typing}
\end{figure}

The translation function $[|\ |]$ maps the typing context $\nonterm G$ to some logic.
In the subsequent text we assume the oracle can decide the resulting proposition
(otherwise it might be left as a separate lemma to be filled out by the user in the core language, or rejected altogether).

For the example oracle being an SMT solver and the syntax of terms also including mathematics, $[|\ |]$ might be defined as
\begin{equation}
\begin{aligned}
  & [| \emptyset |] = \top																						\\
  & [| \nonterm G, x : \{ v : \nonterm B | \nonterm r \} |] = [| \nonterm G |] \land [| \{x/v\} \nonterm r |]   \\
  & [| \nonterm r_1 \land \nonterm r_2 |] = [| \nonterm r_1 |] \land [| \nonterm r_2 |]							\\
  & \cdots TODO
\end{aligned}
\end{equation}

\subsection{Core language}

\begin{figure}[ht]
  \footnotesize
  \nonterms{ec,s}
  \caption{Core language syntax}
  \label{fig:core_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[CT]{$\nonterm G \vdash \nonterm{ec}_1 : \nonterm{ec}_2$}{core typing}{Sort,Var,Weaken,Form,App,Abs,Conv}
  \caption{Core language typing rules}
  \label{fig:surface_typing}
\end{figure}

We also establish some derived entities in the target language to simplify the subsequent exposition:

\begin{itemize}
  \item Non-dependent function type:
	\[
	  \tau_1 \rightarrow \tau_2 := \Pi x : \tau_1. \tau_2,
	\]
	where $\tau_2$ does not have $x$ free.
  \item Dependent pair type, with the first component being a value $x$ of type $\tau$ and the second component being of type $P x$:
	\[
	  \{ x : \tau\ **\ P x \} := \Pi \alpha : \star. (\Pi x : \tau. P x \rightarrow \alpha) \rightarrow \alpha.
	\]
  \item Accessing the first and second component of the dependent pair:
	\[
	  \text{fst} := TODO,
	\]
	\[
	  \text{snd} := TODO.
	\]
  \item Non-dependent pair type:
	\[
	  (\tau_1, \tau_2) := \{ x : \tau_1\ **\ (\lambda \_ : \tau_1. \tau_2) x \}.
	\]
\end{itemize}

\section{Translation}

\end{document}
