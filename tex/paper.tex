\documentclass[a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{ottalt}
\usepackage{subcaption}
\usepackage{cite}
\usepackage{amsthm}

\addtolength{\topmargin}{-1.05in}
\addtolength{\textheight}{1.55in}

\newtheorem{theorem}{Theorem}

\begin{document}

\newNTclass{nonterm}
\newnonterm e \varepsilon
\newnonterm{es}{\varepsilon}
\newnonterm{ec}{\hat\varepsilon}
\newnonterm r \rho
\newnonterm{ts}{\tau}
\newnonterm s s
\newnonterm B B
\newnonterm G \Gamma
\newnonterm{GC}{\hat\Gamma}
\newnonterm{binop}{\odot}

\newNTclass{gterm}
\newgterm x x
\newgterm v v
\newgterm n n

\inputott{surface.ott}

\title{Compiling refinement types to dependent types}

\maketitle

\section{Introduction}

\section{Overview}

%TODO describe the notion of the oracle (like an SMT solver) and what we expect of the oracle.

\section{Calculi definitions}

\subsection{Surface language}

\begin{figure}[ht]
  \footnotesize
  \begin{subfigure}{.6\textwidth}
    \nonterms{es}
    \caption{Term level}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
    \nonterms{G,r,B,ts}
    \caption{Type level}
  \end{subfigure}
  \caption{Surface language syntax}
  \label{fig:surface_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[TWF]{$\nonterm G \vdash \nonterm{ts} \text{ ok}$}{type well-formedness}{TrueRef,Base,Conj,Arr}
  \drules[T]{$\nonterm G \vdash \nonterm{es} : \nonterm{ts}$}{term typing}{BoolTop,BoolBot,Var,Abs,App,If,Sub}
  \caption{Surface language typing}
  \label{fig:surface_typing}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[ST]{$\nonterm G \vdash \nonterm{ts}_1 <: \nonterm{ts}_2$}{subtyping}{Base,Arr}
  \caption{Surface language subtyping}
  \label{fig:surface_subtyping}
\end{figure}

The translation function $[|\ |]$ maps the typing context $\nonterm G$ to some logic:
\begin{equation}
\begin{aligned}
  & [| \emptyset |]                                         && \triangleq && \top																						  \\
  & [| \nonterm G, x : \{ v : \nonterm B | \nonterm r \} |] && \triangleq && [| \nonterm G |] \land [| \{x/v\} \nonterm r |]  \\
  & [| \nonterm r_1 \land \nonterm r_2 |]                   && \triangleq && [| \nonterm r_1 |] \land [| \nonterm r_2 |]      \\
  & [| \nonterm{es} |]                                      && \triangleq && \text{oracle}(\nonterm{es})                      \\
  & [| \nonterm{es}_1 = \nonterm{es}_2 |]                   && \triangleq && \text{oracle}(\nonterm{es}_1 = \nonterm{es}_2)   \\
\end{aligned}
\end{equation}

The last two equations represent the assumption
that the oracle knows how to translate the elementary refinements being the terms $\nonterm{es}$
or equality propositions $\nonterm{es}_1 = \nonterm{es}_2$.

%TODO define substitutions on the \nonterm r

In the subsequent text we also assume the oracle can decide the resulting proposition
(otherwise it might be left as a separate lemma to be filled out by the user in the core language, or rejected altogether).

\subsection{Core language}

We take $\lambda C$ \cite{Nederpelt14} enriched with integers and case-splitting as our core dependently typed language.

\begin{figure}[ht]
  \footnotesize
  \nonterms{ec,s}
  \caption{Core language syntax}
  \label{fig:core_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[CT]{$\nonterm G \vdash \nonterm{ec}_1 : \nonterm{ec}_2$}{core typing}{Sort,Var,Weaken,Form,App,Abs,Conv}
  \caption{Core language typing rules}
  \label{fig:core_typing}
\end{figure}

We also establish some derived entities in the core language to simplify the subsequent exposition:

\begin{itemize}
  \item Non-dependent function type:
    \[
      \tau_1 \rightarrow \tau_2 \triangleq \Pi \_ : \tau_1. \tau_2.
    \]
  \item Dependent pair type, or $\Sigma$-type, with the first component being a value $x$ of type $\tau$ and the second component being of type $P x$:
    \[
      \{ x : \tau\ **\ P x \} \triangleq \Pi \alpha : \star. (\Pi x : \tau. P x \rightarrow \alpha) \rightarrow \alpha.
    \]
  \item Accessing the first and second component of the dependent pair:
    \[
      \text{fst} \triangleq TODO,
    \]
    \[
      \text{snd} \triangleq TODO.
    \]
  \item Non-dependent pair type:
    \[
      (\tau_1, \tau_2) \triangleq \{ x : \tau_1\ **\ (\lambda \_ : \tau_1. \tau_2) x \}.
    \]
  \item Equality of expressions $\nonterm{ec}_1, \nonterm{ec}_2$ of type $S$:
    \[
      \nonterm{ec}_1 \equiv \nonterm{ec}_2 \triangleq \Pi P : S \rightarrow \star. (P x \rightarrow P y, P y \rightarrow P x).
    \]
    Careful reader will recognize this as the Leibniz equality \cite{FindSomethingForThis}.
\end{itemize}

\section{Translation}

We translate the surface language contexts, types and terms into the corresponding core language entities
using the $\mu_\Gamma$, $\mu_\tau$ and $\mu_\varepsilon$ functions respectively,
which are defined mutually recursively.

We start with defining $\mu_\Gamma$:
\begin{equation}
\begin{aligned}
  & \mu_\Gamma(\emptyset)                                       && \triangleq \emptyset                                                     \\
  & \mu_\Gamma(\nonterm G, \gterm x : \nonterm{ts})             && \triangleq \nonterm{GC},
                                                                    \gterm x : \mu_\tau(\nonterm{ts})                                       \\
  & \mu_\Gamma(\nonterm G, \nonterm{es}_1 = \nonterm{es}_2)     && \triangleq \nonterm{GC},
                                                                    \mu_\varepsilon(\nonterm{es}_1) \equiv \mu_\varepsilon(\nonterm{es}_2)  \\
\end{aligned}
\end{equation}

$\mu_\tau$ is defined as follows:
\begin{equation}
\begin{aligned}
  & \mu_\tau( (x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2)  && \triangleq \Pi x : \mu_\tau(\nonterm{ts}_1). \mu_\tau(\nonterm{ts}_2)  \\
  & \mu_\tau( \{ v : \nonterm{ts} | \nonterm{r} \})             && \triangleq \{ v : \mu_\tau(\nonterm{ts})\ **\ \mu_\tau(\nonterm r) \}  \\
  & \mu_\tau( \nonterm r_1 \land \nonterm r_2 )                 && \triangleq ( \mu_\tau(\nonterm r_1) , \mu_\tau(\nonterm r_2))          \\
  & \mu_\tau( \nonterm{es} )                                    && \triangleq \mu_\varepsilon(\nonterm{es}) = \text{True}                 \\
%TODO add syntax/typing rules for True
  & \mu_\tau(B)                                                 && \triangleq B                                                           \\
\end{aligned}
\end{equation}
Or, in words:
\begin{itemize}
  \item (dependent) arrow types are translated to the corresponding $\Pi$-types,
  \item refined types are translated to the corresponding $\Sigma$-types,
  \item atomic refinements (which are $\text{Bool}$-typed terms) are translated to propositions stating that the corresponding term is equal to $\text{True}$,
  \item conjunctions of several (atomic) refinements are represented as tuples of the corresponding atomic translations.
\end{itemize}

\subsection{Correctness}

The correctness of the translation hinges on two key theorems.
The first one claims that a well-typed program in surface language remains well-typed after the translation to the core language.
The second one claims that a well-typed surface language program evaluates to ``the same'' value as the translated one.

\begin{theorem}[Well-typedness preservation]
  For any well-typed surface language term $\nonterm{es}$,
  the result of the translation $\mu_\epsilon(\nonterm{es})$ is ``equivalently'' typeable in the core language:
  \[
    \nonterm G \vdash \nonterm{es} : \nonterm{ts} \implies \mu_\Gamma(\nonterm G) \vdash \mu_\epsilon(\nonterm{es}) : \mu_\tau(\nonterm{ts})
  \]
\end{theorem}
\begin{proof}
\end{proof}

\begin{theorem}[Evaluation equivalence]
  For any well-typed surface language term $\nonterm{es}$, if $\nonterm{es}$ evaluates to v, then $\mu_\varepsilon(\nonterm{es})$ evaluates to $\mu_\varepsilon(v)$:
  %TODO symbols and all that for v
\end{theorem}
\begin{proof}
\end{proof}

\end{document}
