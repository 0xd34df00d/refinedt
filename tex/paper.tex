\documentclass[a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{ottalt}
\usepackage{subcaption}
\usepackage{cite,url,babelbib}
\usepackage[english]{babel}

\addtolength{\topmargin}{-1.05in}
\addtolength{\textheight}{1.55in}

\newtheorem{theorem}{Theorem}

\newcommand{\unit}{u}
\newcommand{\Unit}{\textbf{Unit}}
\newcommand{\unitc}{\hat{u}}
\newcommand{\Unitc}{\widehat{\textbf{Unit}}}
\newcommand{\Int}{\textbf{Int}}

\begin{document}

\newNTclass{nonterm}
\newnonterm e \varepsilon
\newnonterm{es}{\varepsilon}
\newnonterm{ec}{\hat\varepsilon}
\newnonterm r \rho
\newnonterm{ts}{\tau}
\newnonterm s s
\newnonterm l l
\newnonterm B B
\newnonterm G \Gamma
\newnonterm{GC}{\hat\Gamma}
\newnonterm{binop}{\odot}

\newNTclass{gterm}
\newgterm x x
\newgterm v v
\newgterm n n

\inputott{surface.ott}

\title{Compiling refinement types to dependent types}

\maketitle

\section{Introduction}

\section{Overview}

%TODO describe the notion of the oracle (like an SMT solver) and what we expect of the oracle.

\section{Calculi definitions}

\subsection{Surface language}

Our surface language is based on simply typed lambda calculus.
Refinements over the types are, of course, the most important extension.
The other ones are:
\begin{itemize}
  \item dependent arrow types, to allow subsequent refinements refer preceding arguments,
  \item limited form of algebraic data types and dependent pattern matching
    insired by \cite{TAPLVariants,Eisenberg16},
    to illustrate reasoning about those widely used constructs.
\end{itemize}

\begin{figure}[ht]
  \footnotesize
  \begin{subfigure}{.6\textwidth}
    \nonterms{es,l}
    \caption{Term level}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
    \nonterms{G,r,B,ts}
    \caption{Type level}
  \end{subfigure}
  \caption{Surface language syntax}
  \label{fig:surface_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[TWF]{$\nonterm G \vdash \nonterm{ts} \text{ ok}$}{type well-formedness}{TrueRef,Base,Conj,Arr}
  \drules[T]{$\nonterm G \vdash \nonterm{es} : \nonterm{ts}$}{term typing}{Unit,Var,Abs,App,Case,Con,Sub}
  \caption{Surface language typing}
  \label{fig:surface_typing}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[ST]{$\nonterm G \vdash \nonterm{ts}_1 <: \nonterm{ts}_2$}{subtyping}{Base,Arr}
  \caption{Surface language subtyping}
  \label{fig:surface_subtyping}
\end{figure}

We introduce a shorthand notation $\top$ denoting some tautology
which we use for trivial refinements that do not carry any extra information.
In particular, one good way to define $\top$ is
to state the equality of the sole inhabitant of $\Unit$ to itself:
$\top \triangleq \unit = \unit$.

The surface language might also have other base types (for example, $\Int$),
elements of syntax (like numbers and operations on them)
as well as typing rules relating those,
but we omit them for the sake of brevity.

We also have the following concessions:
\begin{itemize}
  \item The syntax only allows refinements on base types.
    Note that this does not restrict the expressive power of the language.
    For instance, a refinement on a function that we might otherwise wish to write as
    \[
      (x : \Int) \rightarrow \{ v : \Int \rightarrow \Int | v x = 0 \} \rightarrow \Int
    \]
    might instead be expressed via a dummy parameter:
    \[
      (x : \Int) \rightarrow (f : \Int \rightarrow \Int) \rightarrow \{ \_ : \Unit | f x = 0 \} \rightarrow \Int.
    \]
  \item Our algebraic data types only allow a single ``field'' in each constructor.
    One way to alleviate this is to introduce tuples,
    but doing so would complicate the exposition
    without any benefit for illustrating the main idea of this work.
\end{itemize}

The translation function $[|\ |]$ maps the typing context $\nonterm G$ to some logic
that the oracle can handle.
It might be defined as follows:
\begin{equation}
\begin{aligned}
  & [|\ \emptyset\ |]                                         && \triangleq && \top																						            \\
  & [|\ \nonterm G, x : \{ v : \nonterm B | \nonterm r \}\ |] && \triangleq && [|\ \nonterm G\ |] \land [|\ [ v \mapsto x ] \nonterm r\ |]  \\
  & [|\ \nonterm r_1 \land \nonterm r_2\ |]                   && \triangleq && [|\ \nonterm r_1\ |] \land [|\ \nonterm r_2\ |]              \\
  & [|\ \nonterm{es}_1 = \nonterm{es}_2\ |]                   && \triangleq && \text{oracle}(\nonterm{es}_1 = \nonterm{es}_2)             \\
\end{aligned}
\end{equation}

The last equation represents the assumption
that the oracle knows how to translate the atomic refinements.

%TODO define substitutions on the \nonterm r

In the subsequent text we also assume the oracle can decide the resulting proposition
(otherwise it might be left as a separate lemma to be filled out by the user in the core language, or rejected altogether).

\subsection{Core language}

We take $\lambda C$ \cite{TTFPLambdaC}
with a unit type as our core dependently typed language.

\begin{figure}[ht]
  \footnotesize
  \nonterms{ec,s}
  \caption{Core language syntax}
  \label{fig:core_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[CT]{$\nonterm G \vdash \nonterm{ec}_1 : \nonterm{ec}_2$}{core typing}{Sort,UnitType,UnitTerm,Var,Weaken,Form,App,Abs,Conv}
  \caption{Core language typing rules}
  \label{fig:core_typing}
\end{figure}

Although the syntax doesn't mention $\tau$, we will use it as a metavariable
where a type (an inhabitant of $\star$) is expected.

\newcommand{\dast}{\ **\ }

We also establish some derived entities in the core language to simplify the subsequent exposition:

\begin{itemize}
  \item Non-dependent function type:
    \[
      \tau_1 \rightarrow \tau_2 \triangleq \Pi \_ : \tau_1. \tau_2.
    \]
  \item Dependent pair type, or $\Sigma$-type, with the first component being a value $x$ of type $\tau$ and the second component being of type $P x$:
    \[
      (x : \tau \dast P x) \triangleq \Pi \alpha : \star. (\Pi x : \tau. P x \rightarrow \alpha) \rightarrow \alpha,
    \]
    with the corresponding constructor (we overload the syntax here to resemble Idris):
    \[
      (x \dast p) \triangleq \lambda \alpha : \star. \lambda f : (\Pi x' : \tau. P x' \rightarrow \alpha). f x p
    \]
    and projections
    \[
      \text{fst} \triangleq \lambda \sigma : (x : \tau \dast P x). \sigma \tau (\lambda x' : \tau. \lambda \_ : P x'. x'),
    \]
    \[
      \text{snd} \triangleq \lambda \sigma : (x : \tau \dast P x). \sigma \tau (\lambda x' : \tau. \lambda p : P x'. p),
    \]
  \item Non-dependent pair type:
    \[
      (\tau_1, \tau_2) \triangleq \{ x : \tau_1\ **\ (\lambda \_ : \tau_1. \tau_2) x \}.
    \]
  \item Equality of expressions $\nonterm{ec}_1, \nonterm{ec}_2$ of type $S$:
    \[
      \nonterm{ec}_1 \equiv \nonterm{ec}_2 \triangleq \Pi P : S \rightarrow \star. (P x \rightarrow P y, P y \rightarrow P x).
    \]
    The reader might recognize this as the Leibniz equality \cite{FindSomethingForThis}.
  \item ADTs, expressed using the Boehm-Berarducci encoding \cite{Bohm85}:
    \[
      \langle \overline{l_i : \nonterm{ts}_i}^i \rangle
        \triangleq \Pi \alpha : \star. \overline{(\nonterm{ts}_i \rightarrow \alpha)}^i \rightarrow \alpha.
    \]
\end{itemize}

\section{Translation}

\newcommand{\tranctx}{\mu_\Gamma}
\newcommand{\tranty}{\mu_\tau}
\newcommand{\tranterm}{\mu_\varepsilon}

We translate the surface language contexts, types and terms into the corresponding core language entities
using the $\mu_\Gamma$, $\mu_\tau$ and $\mu_\varepsilon$ functions respectively,
which are defined mutually recursively.

\paragraph{Contexts.}
We start with defining $\tranctx$,
which merely translates the types of the bindings in the context from the surface language into the core language:
\begin{equation}
\begin{aligned}
  & \tranctx(\emptyset)                                       && \triangleq \emptyset                                               \\
  & \tranctx(\nonterm G, \gterm x : \nonterm{ts})             && \triangleq \tranctx(\nonterm G), \gterm x : \tranty(\nonterm{ts})  \\
\end{aligned}
\end{equation}

\paragraph{Types.}
$\tranty$ is defined as follows,
with the slight abuse of notation to allow ``recursive'' calls
on the refinement part of the surface language syntax:
\begin{equation}
\begin{aligned}
  & \tranty( (x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2)  && \triangleq \Pi x : \tranty(\nonterm{ts}_1). \tranty(\nonterm{ts}_2)     \\
  & \tranty( \{ v : \nonterm{ts} | \nonterm{r} \})             && \triangleq \{ v : \tranty(\nonterm{ts})\ **\ \tranty(\nonterm r) \}     \\
  & \tranty( \nonterm r_1 \land \nonterm r_2 )                 && \triangleq ( \tranty(\nonterm r_1) , \tranty(\nonterm r_2))             \\
  & \tranty( \nonterm{es}_1 = \nonterm{es}_2 )                 && \triangleq \tranterm(\nonterm{es}_1) \equiv \tranterm(\nonterm{es}_2)   \\
  & \tranty(B)                                                 && \triangleq B                                                            \\
%TODO this last one is not well-defined
\end{aligned}
\end{equation}
Or, in words:
\begin{itemize}
  \item (dependent) arrow types are translated to the corresponding $\Pi$-types,
  \item refined types are translated to the corresponding $\Sigma$-types,
  \item atomic refinements, being propositions about surface language terms equality,
    are translated to propositions stating the equality of translated core language terms,
  \item conjunctions of several (atomic) refinements are represented as tuples of the corresponding atomic translations.
\end{itemize}

\paragraph{Terms.}
Finally we define $\tranterm$:
\begin{equation}
\begin{aligned}
  & \tranterm(x) &&
    \triangleq x                                                              \\
  & \tranterm(\lambda x : \nonterm{ts}. \nonterm{es})  &&
    \triangleq \lambda x : \tranty(\nonterm{ts}). \tranterm(\nonterm{es})     \\
  & \tranterm(\nonterm{es}_1 \nonterm{es}_2)  &&
    \triangleq \tranterm(\nonterm{es}_1) \tranterm(\nonterm{es}_2)            \\
\end{aligned}
\end{equation}

\subsection{Correctness}

The correctness of the translation hinges on two key theorems.
The first one claims that a well-typed program in surface language remains well-typed after the translation to the core language.
The second one claims that a well-typed surface language program evaluates to ``the same'' value as the translated one.

\begin{theorem}[Well-typedness preservation]
  For any well-typed surface language term $\nonterm{es}$,
  the result of the translation $\tranterm(\nonterm{es})$ is ``equivalently'' typeable in the core language:
  \[
    \nonterm G \vdash \nonterm{es} : \nonterm{ts} \implies \tranctx(\nonterm G) \vdash \tranterm(\nonterm{es}) : \tranty(\nonterm{ts})
  \]
\end{theorem}
\begin{proof}
  We prove this by induction on the derivation of the typeability of $\nonterm{es}$.
  In particular, we consider the last typing rule used:
\end{proof}

\begin{theorem}[Evaluation equivalence]
  If a well-typed surface language term $\nonterm{es}$ evaluates to v, then $\tranterm(\nonterm{es})$ evaluates to $\tranterm(v)$:
  %TODO symbols and all that for v
\end{theorem}
\begin{proof}
\end{proof}

\bibliographystyle{babunsrt-lf}
\bibliography{biblio}

\end{document}
