\documentclass[a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amsfonts}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{ottalt}
\usepackage{subcaption}

\addtolength{\topmargin}{-1.75in}
\addtolength{\textheight}{2.75in}

\begin{document}

\newNTclass{nonterm}
\newnonterm e \varepsilon
\newnonterm{eS}{\varepsilon}
\newnonterm{ec}{\overline\varepsilon}
\newnonterm r \rho
\newnonterm{tS}{\tau}
\newnonterm{tC}{\overline\tau}
\newnonterm s s
\newnonterm B B
\newnonterm G \Gamma
\newnonterm{GC}{\overline\Gamma}
\newnonterm{binop}{\odot}

\newNTclass{gterm}
\newgterm x x
\newgterm v v
\newgterm n n

\inputott{surface.ott}

\title{Compiling refinement types to dependent types}

\maketitle

\section{Introduction}

\section{Overview}

\section{Calculi definitions}

\subsection{Surface language}

\begin{figure}[ht]
  \footnotesize
  \begin{subfigure}{.6\textwidth}
	\nonterms{eS}
	\caption{Term level}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
	\nonterms{r,B,tS}
	\caption{Type level}
  \end{subfigure}
  \caption{Surface language syntax}
  \label{fig:surface_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[TWF]{$\nonterm G \vdash \nonterm{tS} \text{ ok}$}{type well-formedness}{TrueRef,Base,Conj,Arr}
  \drules[T]{$\nonterm G \vdash \nonterm{eS} : \nonterm{tS}$}{term typing}{BoolTop,BoolBot,Var,Abs,App,If,Sub}
  \drules[ST]{$\nonterm G \vdash \nonterm{tS}_1 <: \nonterm{tS}_2$}{subtyping}{Base,Arr}
  \caption{Surface language typing rules}
  \label{fig:surface_typing}
\end{figure}

The translation function $[|\ |]$ maps the typing context $\nonterm G$ to some logic.
In the subsequent text we assume the oracle can decide the resulting proposition
(otherwise it might be left as a separate lemma to be filled out by the user in the core language, or rejected altogether).

For the example oracle being an SMT solver and the syntax of terms also including mathematics, $[|\ |]$ might be defined as
\begin{equation}
\begin{aligned}
  & [| \emptyset |]                                         && \coloneqq \top																						 \\
  & [| \nonterm G, x : \{ v : \nonterm B | \nonterm r \} |] && \coloneqq [| \nonterm G |] \land [| \{x/v\} \nonterm r |] \\
  & [| \nonterm r_1 \land \nonterm r_2 |]                   && \coloneqq [| \nonterm r_1 |] \land [| \nonterm r_2 |]		 \\
  & \cdots TODO
\end{aligned}
\end{equation}

%TODO define substitutions on the \nonterm r

\subsection{Core language}

We take $\lambda C$ \cite{Nederpelt14} enriched with integers and case-splitting as our core dependently typed language.

\begin{figure}[ht]
  \footnotesize
  \nonterms{ec,s}
  \caption{Core language syntax}
  \label{fig:core_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[CT]{$\nonterm G \vdash \nonterm{ec}_1 : \nonterm{ec}_2$}{core typing}{Sort,Var,Weaken,Form,App,Abs,Conv}
  \caption{Core language typing rules}
  \label{fig:surface_typing}
\end{figure}

We also establish some derived entities in the target language to simplify the subsequent exposition:

\begin{itemize}
  \item Non-dependent function type:
  \[
    \tau_1 \rightarrow \tau_2 \coloneqq \Pi x : \tau_1. \tau_2,
  \]
  where $\tau_2$ does not have $x$ free.
  \item Dependent pair type, or $\Sigma$-type, with the first component being a value $x$ of type $\tau$ and the second component being of type $P x$:
  \[
    \{ x : \tau\ **\ P x \} \coloneqq \Pi \alpha : \star. (\Pi x : \tau. P x \rightarrow \alpha) \rightarrow \alpha.
  \]
  \item Accessing the first and second component of the dependent pair:
  \[
    \text{fst} \coloneqq TODO,
  \]
  \[
    \text{snd} \coloneqq TODO.
  \]
  \item Non-dependent pair type:
  \[
    (\tau_1, \tau_2) \coloneqq \{ x : \tau_1\ **\ (\lambda \_ : \tau_1. \tau_2) x \}.
  \]
\end{itemize}

\section{Translation}

We translate the surface language types and terms using the $\mu_\tau$ and $\mu_\varepsilon$ functions respectively.
$\mu_\tau$ is defined as follows:
\begin{equation}
\begin{aligned}
  & \mu_\tau( (x : \nonterm{tS}_1) \rightarrow \nonterm{tS}_2)  && \coloneqq \Pi x : \mu_\tau(\nonterm{tS}_1). \mu_\tau(\nonterm{tS}_2)  \\
  & \mu_\tau( \{ v : \nonterm{tS} | \nonterm{r} \})             && \coloneqq \{ v : \mu_\tau(\nonterm{tS})\ **\ \mu_\tau(\nonterm r) \}  \\
  & \mu_\tau( \nonterm r_1 \land \nonterm r_2 )                 && \coloneqq ( \mu_\tau(\nonterm r_1) , \mu_\tau(\nonterm r_2))          \\
  & \mu_\tau( \nonterm{eS} )                                    && \coloneqq \mu_\varepsilon(\nonterm{eS}) = \text{True}                 \\
  & \mu_\tau(B)                                                 && \coloneqq B                                                           \\
\end{aligned}
\end{equation}
Or, in words:
\begin{itemize}
  \item (dependent) arrow types are translated to the corresponding $\Pi$-types,
  \item refined types are translated to the corresponding $\Sigma$-types,
  \item atomic refinements (which are $\text{Bool}$-typed terms) are translated to propositions stating that the corresponding term is equal to $\text{True}$,
  \item conjunctions of several (atomic) refinements are represented as tuples of the corresponding atomic translations.
\end{itemize}


\end{document}
