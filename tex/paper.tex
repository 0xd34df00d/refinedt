\documentclass[a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{ottalt}
\usepackage{subcaption}
\usepackage{cite}
\usepackage{amsthm}

\addtolength{\topmargin}{-1.05in}
\addtolength{\textheight}{1.55in}

\newtheorem{theorem}{Theorem}

\begin{document}

\newNTclass{nonterm}
\newnonterm e \varepsilon
\newnonterm{es}{\varepsilon}
\newnonterm{ec}{\hat\varepsilon}
\newnonterm r \rho
\newnonterm{ts}{\tau}
\newnonterm s s
\newnonterm l l
\newnonterm B B
\newnonterm G \Gamma
\newnonterm{GC}{\hat\Gamma}
\newnonterm{binop}{\odot}

\newNTclass{gterm}
\newgterm x x
\newgterm v v
\newgterm n n

\inputott{surface.ott}

\title{Compiling refinement types to dependent types}

\maketitle

\section{Introduction}

\section{Overview}

%TODO describe the notion of the oracle (like an SMT solver) and what we expect of the oracle.

\section{Calculi definitions}

\subsection{Surface language}

\begin{figure}[ht]
  \footnotesize
  \begin{subfigure}{.6\textwidth}
    \nonterms{es,l}
    \caption{Term level}
  \end{subfigure}
  \begin{subfigure}{.5\textwidth}
    \nonterms{G,r,B,ts}
    \caption{Type level}
  \end{subfigure}
  \caption{Surface language syntax}
  \label{fig:surface_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[TWF]{$\nonterm G \vdash \nonterm{ts} \text{ ok}$}{type well-formedness}{TrueRef,Base,Conj,Arr}
  \drules[T]{$\nonterm G \vdash \nonterm{es} : \nonterm{ts}$}{term typing}{BoolTop,BoolBot,Var,Abs,App,If,Sub}
  \caption{Surface language typing}
  \label{fig:surface_typing}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[ST]{$\nonterm G \vdash \nonterm{ts}_1 <: \nonterm{ts}_2$}{subtyping}{Base,Arr}
  \caption{Surface language subtyping}
  \label{fig:surface_subtyping}
\end{figure}

The surface language might also have other base types (for example, $\mathbf{Int}$),
elements of syntax (like numbers and operations on them)
as well as typing rules relating those,
but we omit them for the sake of brevity.

Note that although the syntax does not allow refining function types or ADTs,
it does not restrict the expressive power of the language.
For instance, a refinement on a function that we might otherwise wish to write as
\[
  (x : \mathbf{Int}) \rightarrow \{ v : \mathbf{Int} \rightarrow \mathbf{Int} | v x = 0 \} \rightarrow \mathbf{Int}
\]
might instead be expressed via a dummy parameter:
\[
  (x : \mathbf{Int}) \rightarrow (f : \mathbf{Int} \rightarrow \mathbf{Int}) \rightarrow \{ \_ : \mathbf{Unit} | f x = 0 \} \rightarrow \mathbf{Int}
\]

The translation function $[|\ |]$ maps the typing context $\nonterm G$ to some logic
that the oracle can handle.
It might be defined as follows:
\begin{equation}
\begin{aligned}
  & [|\ \emptyset\ |]                                         && \triangleq && \top																						            \\
  & [|\ \nonterm G, x : \{ v : \nonterm B | \nonterm r \}\ |] && \triangleq && [|\ \nonterm G\ |] \land [|\ [ v \mapsto x ] \nonterm r\ |]  \\
  & [|\ \nonterm r_1 \land \nonterm r_2\ |]                   && \triangleq && [|\ \nonterm r_1\ |] \land [|\ \nonterm r_2\ |]              \\
  & [|\ \nonterm{es}_1 = \nonterm{es}_2\ |]                   && \triangleq && \text{oracle}(\nonterm{es}_1 = \nonterm{es}_2)             \\
\end{aligned}
\end{equation}

The last equation represents the assumption
that the oracle knows how to translate the atomic refinements.

%TODO define substitutions on the \nonterm r

In the subsequent text we also assume the oracle can decide the resulting proposition
(otherwise it might be left as a separate lemma to be filled out by the user in the core language, or rejected altogether).

\subsection{Core language}

We take $\lambda C$ \cite{Nederpelt14} enriched with case-splitting as our core dependently typed language.

\begin{figure}[ht]
  \footnotesize
  \nonterms{ec,s}
  \caption{Core language syntax}
  \label{fig:core_syntax}
\end{figure}

\begin{figure}[ht]
  \footnotesize
  \drules[CT]{$\nonterm G \vdash \nonterm{ec}_1 : \nonterm{ec}_2$}{core typing}{Sort,Var,Weaken,Form,App,Abs,Conv}
  \caption{Core language typing rules}
  \label{fig:core_typing}
\end{figure}

We also establish some derived entities in the core language to simplify the subsequent exposition:

\begin{itemize}
  \item Non-dependent function type:
    \[
      \tau_1 \rightarrow \tau_2 \triangleq \Pi \_ : \tau_1. \tau_2.
    \]
  \item Dependent pair type, or $\Sigma$-type, with the first component being a value $x$ of type $\tau$ and the second component being of type $P x$:
    \[
      \{ x : \tau\ **\ P x \} \triangleq \Pi \alpha : \star. (\Pi x : \tau. P x \rightarrow \alpha) \rightarrow \alpha,
    \]
    with the corresponding accessors:
    \[
      \text{fst} \triangleq TODO,
    \]
    \[
      \text{snd} \triangleq TODO.
    \]
  \item Non-dependent pair type:
    \[
      (\tau_1, \tau_2) \triangleq \{ x : \tau_1\ **\ (\lambda \_ : \tau_1. \tau_2) x \}.
    \]
  \item Equality of expressions $\nonterm{ec}_1, \nonterm{ec}_2$ of type $S$:
    \[
      \nonterm{ec}_1 \equiv \nonterm{ec}_2 \triangleq \Pi P : S \rightarrow \star. (P x \rightarrow P y, P y \rightarrow P x).
    \]
    Careful reader will recognize this as the Leibniz equality \cite{FindSomethingForThis}.
\end{itemize}

\section{Translation}

We translate the surface language contexts, types and terms into the corresponding core language entities
using the $\mu_\Gamma$, $\mu_\tau$ and $\mu_\varepsilon$ functions respectively,
which are defined mutually recursively.

We start with defining $\mu_\Gamma$,
which merely translates the types of the bindings in the context from the surface language into the core language:
\begin{equation}
\begin{aligned}
  & \mu_\Gamma(\emptyset)                                       && \triangleq \emptyset                                                     \\
  & \mu_\Gamma(\nonterm G, \gterm x : \nonterm{ts})             && \triangleq \mu_\Gamma(\nonterm G), \gterm x : \mu_\tau(\nonterm{ts})     \\
\end{aligned}
\end{equation}

$\mu_\tau$ is defined as follows,
with the slight abuse of notation to allow ``recursive'' calls
on refinement part of the surface language syntax:
\begin{equation}
\begin{aligned}
  & \mu_\tau( (x : \nonterm{ts}_1) \rightarrow \nonterm{ts}_2)  && \triangleq \Pi x : \mu_\tau(\nonterm{ts}_1). \mu_\tau(\nonterm{ts}_2)              \\
  & \mu_\tau( \{ v : \nonterm{ts} | \nonterm{r} \})             && \triangleq \{ v : \mu_\tau(\nonterm{ts})\ **\ \mu_\tau(\nonterm r) \}              \\
  & \mu_\tau( \nonterm r_1 \land \nonterm r_2 )                 && \triangleq ( \mu_\tau(\nonterm r_1) , \mu_\tau(\nonterm r_2))                      \\
  & \mu_\tau( \nonterm{es}_1 = \nonterm{es}_2 )                 && \triangleq \mu_\varepsilon(\nonterm{es}_1) \equiv \mu_\varepsilon(\nonterm{es}_2)  \\
  & \mu_\tau(B)                                                 && \triangleq B                                                                       \\
%TODO this last one is not well-defined
\end{aligned}
\end{equation}
Or, in words:
\begin{itemize}
  \item (dependent) arrow types are translated to the corresponding $\Pi$-types,
  \item refined types are translated to the corresponding $\Sigma$-types,
  \item atomic refinements, being propositions about surface language terms equality,
    are translated to propositions stating the equality of translated core language terms,
  \item conjunctions of several (atomic) refinements are represented as tuples of the corresponding atomic translations.
\end{itemize}

\subsection{Correctness}

The correctness of the translation hinges on two key theorems.
The first one claims that a well-typed program in surface language remains well-typed after the translation to the core language.
The second one claims that a well-typed surface language program evaluates to ``the same'' value as the translated one.

\begin{theorem}[Well-typedness preservation]
  For any well-typed surface language term $\nonterm{es}$,
  the result of the translation $\mu_\epsilon(\nonterm{es})$ is ``equivalently'' typeable in the core language:
  \[
    \nonterm G \vdash \nonterm{es} : \nonterm{ts} \implies \mu_\Gamma(\nonterm G) \vdash \mu_\epsilon(\nonterm{es}) : \mu_\tau(\nonterm{ts})
  \]
\end{theorem}
\begin{proof}
\end{proof}

\begin{theorem}[Evaluation equivalence]
  If a well-typed surface language term $\nonterm{es}$ evaluates to v, then $\mu_\varepsilon(\nonterm{es})$ evaluates to $\mu_\varepsilon(v)$:
  %TODO symbols and all that for v
\end{theorem}
\begin{proof}
\end{proof}

\end{document}
